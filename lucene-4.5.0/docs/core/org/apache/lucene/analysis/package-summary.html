<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_45) on Sat Sep 28 14:03:26 CEST 2013 -->
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<TITLE>
org.apache.lucene.analysis (Lucene 4.5.0 API)
</TITLE>

<META NAME="date" CONTENT="2013-09-28">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="org.apache.lucene.analysis (Lucene 4.5.0 API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/lucene/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/lucene/analysis/tokenattributes/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/apache/lucene/analysis/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package org.apache.lucene.analysis
</H2>
API and code to convert text into indexable/searchable tokens.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/NumericTokenStream.NumericTermAttribute.html" title="interface in org.apache.lucene.analysis">NumericTokenStream.NumericTermAttribute</A></B></TD>
<TD><b>Expert:</b> Use this attribute to get the details of the currently generated token.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A></B></TD>
<TD>An Analyzer builds TokenStreams, which analyze text.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/Analyzer.GlobalReuseStrategy.html" title="class in org.apache.lucene.analysis">Analyzer.GlobalReuseStrategy</A></B></TD>
<TD><B>Deprecated.</B>&nbsp;<I>This implementation class will be hidden in Lucene 5.0.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/Analyzer.PerFieldReuseStrategy.html" title="class in org.apache.lucene.analysis">Analyzer.PerFieldReuseStrategy</A></B></TD>
<TD><B>Deprecated.</B>&nbsp;<I>This implementation class will be hidden in Lucene 5.0.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/Analyzer.ReuseStrategy.html" title="class in org.apache.lucene.analysis">Analyzer.ReuseStrategy</A></B></TD>
<TD>Strategy defining how TokenStreamComponents are reused per call to
 <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html#tokenStream(java.lang.String, java.io.Reader)"><CODE>Analyzer.tokenStream(String, java.io.Reader)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/Analyzer.TokenStreamComponents.html" title="class in org.apache.lucene.analysis">Analyzer.TokenStreamComponents</A></B></TD>
<TD>This class encapsulates the outer components of a token stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/AnalyzerWrapper.html" title="class in org.apache.lucene.analysis">AnalyzerWrapper</A></B></TD>
<TD>Extension to <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> suitable for Analyzers which wrap
 other Analyzers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/CachingTokenFilter.html" title="class in org.apache.lucene.analysis">CachingTokenFilter</A></B></TD>
<TD>This class can be used if the token attributes of a TokenStream
 are intended to be consumed more than once.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/CharFilter.html" title="class in org.apache.lucene.analysis">CharFilter</A></B></TD>
<TD>Subclasses of CharFilter can be chained to filter a Reader
 They can be used as <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/Reader.html?is-external=true" title="class or interface in java.io"><CODE>Reader</CODE></A> with additional offset
 correction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/NumericTokenStream.html" title="class in org.apache.lucene.analysis">NumericTokenStream</A></B></TD>
<TD><b>Expert:</b> This class provides a <A HREF="../../../../org/apache/lucene/analysis/TokenStream.html" title="class in org.apache.lucene.analysis"><CODE>TokenStream</CODE></A>
 for indexing numeric values that can be used by <A HREF="../../../../org/apache/lucene/search/NumericRangeQuery.html" title="class in org.apache.lucene.search"><CODE>NumericRangeQuery</CODE></A> or <A HREF="../../../../org/apache/lucene/search/NumericRangeFilter.html" title="class in org.apache.lucene.search"><CODE>NumericRangeFilter</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/NumericTokenStream.NumericTermAttributeImpl.html" title="class in org.apache.lucene.analysis">NumericTokenStream.NumericTermAttributeImpl</A></B></TD>
<TD>Implementation of <A HREF="../../../../org/apache/lucene/analysis/NumericTokenStream.NumericTermAttribute.html" title="interface in org.apache.lucene.analysis"><CODE>NumericTokenStream.NumericTermAttribute</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/Token.html" title="class in org.apache.lucene.analysis">Token</A></B></TD>
<TD>A Token is an occurrence of a term from the text of a field.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/Token.TokenAttributeFactory.html" title="class in org.apache.lucene.analysis">Token.TokenAttributeFactory</A></B></TD>
<TD><b>Expert:</b> Creates a TokenAttributeFactory returning <A HREF="../../../../org/apache/lucene/analysis/Token.html" title="class in org.apache.lucene.analysis"><CODE>Token</CODE></A> as instance for the basic attributes
 and for all other attributes calls the given delegate factory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/TokenFilter.html" title="class in org.apache.lucene.analysis">TokenFilter</A></B></TD>
<TD>A TokenFilter is a TokenStream whose input is another TokenStream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis">Tokenizer</A></B></TD>
<TD>A Tokenizer is a TokenStream whose input is a Reader.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/TokenStream.html" title="class in org.apache.lucene.analysis">TokenStream</A></B></TD>
<TD>A <code>TokenStream</code> enumerates the sequence of tokens, either from
 <A HREF="../../../../org/apache/lucene/document/Field.html" title="class in org.apache.lucene.document"><CODE>Field</CODE></A>s of a <A HREF="../../../../org/apache/lucene/document/Document.html" title="class in org.apache.lucene.document"><CODE>Document</CODE></A> or from query text.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/apache/lucene/analysis/TokenStreamToAutomaton.html" title="class in org.apache.lucene.analysis">TokenStreamToAutomaton</A></B></TD>
<TD>Consumes a TokenStream and creates an <A HREF="../../../../org/apache/lucene/util/automaton/Automaton.html" title="class in org.apache.lucene.util.automaton"><CODE>Automaton</CODE></A>
  where the transition labels are UTF8 bytes (or Unicode 
  code points if unicodeArcs is true) from the <A HREF="../../../../org/apache/lucene/analysis/tokenattributes/TermToBytesRefAttribute.html" title="interface in org.apache.lucene.analysis.tokenattributes"><CODE>TermToBytesRefAttribute</CODE></A>.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package org.apache.lucene.analysis Description
</H2>

<P>
<p>API and code to convert text into indexable/searchable tokens.  Covers <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> and related classes.</p>
<h2>Parsing? Tokenization? Analysis!</h2>
<p>
Lucene, an indexing and search library, accepts only plain text input.
<p>
<h2>Parsing</h2>
<p>
Applications that build their search capabilities upon Lucene may support documents in various formats &ndash; HTML, XML, PDF, Word &ndash; just to name a few.
Lucene does not care about the <i>Parsing</i> of these and other document formats, and it is the responsibility of the 
application using Lucene to use an appropriate <i>Parser</i> to convert the original format into plain text before passing that plain text to Lucene.
<p>
<h2>Tokenization</h2>
<p>
Plain text passed to Lucene for indexing goes through a process generally called tokenization. Tokenization is the process
of breaking input text into small indexing elements &ndash; tokens.
The way input text is broken into tokens heavily influences how people will then be able to search for that text. 
For instance, sentences beginnings and endings can be identified to provide for more accurate phrase 
and proximity searches (though sentence identification is not provided by Lucene).
<p>
  In some cases simply breaking the input text into tokens is not enough
  &ndash; a deeper <i>Analysis</i> may be needed. Lucene includes both
  pre- and post-tokenization analysis facilities.
</p>
<p>
  Pre-tokenization analysis can include (but is not limited to) stripping
  HTML markup, and transforming or removing text matching arbitrary patterns
  or sets of fixed strings.
</p>
<p>
  There are many post-tokenization steps that can be done, including 
  (but not limited to):
</p>
<ul>
  <li><a href="http://en.wikipedia.org/wiki/Stemming">Stemming</a> &ndash; 
      Replacing words with their stems. 
      For instance with English stemming "bikes" is replaced with "bike"; 
      now query "bike" can find both documents containing "bike" and those containing "bikes".
  </li>
  <li><a href="http://en.wikipedia.org/wiki/Stop_words">Stop Words Filtering</a> &ndash; 
      Common words like "the", "and" and "a" rarely add any value to a search.
      Removing them shrinks the index size and increases performance.
      It may also reduce some "noise" and actually improve search quality.
  </li>
  <li><a href="http://en.wikipedia.org/wiki/Text_normalization">Text Normalization</a> &ndash; 
      Stripping accents and other character markings can make for better searching.
  </li>
  <li><a href="http://en.wikipedia.org/wiki/Synonym">Synonym Expansion</a> &ndash; 
      Adding in synonyms at the same token position as the current word can mean better 
      matching when users search with words in the synonym set.
  </li>
</ul> 
<p>
<h2>Core Analysis</h2>
<p>
  The analysis package provides the mechanism to convert Strings and Readers
  into tokens that can be indexed by Lucene.  There are four main classes in 
  the package from which all analysis processes are derived.  These are:
</p>
<ul>
  <li>
    <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> &ndash; An Analyzer is 
    responsible for building a 
    <A HREF="../../../../org/apache/lucene/analysis/TokenStream.html" title="class in org.apache.lucene.analysis"><CODE>TokenStream</CODE></A> which can be consumed
    by the indexing and searching processes.  See below for more information
    on implementing your own Analyzer.
  </li>
  <li>
    CharFilter &ndash; CharFilter extends
    <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/Reader.html?is-external=true" title="class or interface in java.io"><CODE>Reader</CODE></A> to perform pre-tokenization substitutions, 
    deletions, and/or insertions on an input Reader's text, while providing
    corrected character offsets to account for these modifications.  This
    capability allows highlighting to function over the original text when 
    indexed tokens are created from CharFilter-modified text with offsets
    that are not the same as those in the original text. Tokenizers'
    constructors and reset() methods accept a CharFilter.  CharFilters may
    be chained to perform multiple pre-tokenization modifications.
  </li>
  <li>
    <A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A> &ndash; A Tokenizer is a 
    <A HREF="../../../../org/apache/lucene/analysis/TokenStream.html" title="class in org.apache.lucene.analysis"><CODE>TokenStream</CODE></A> and is responsible for
    breaking up incoming text into tokens. In most cases, an Analyzer will
    use a Tokenizer as the first step in the analysis process.  However,
    to modify text prior to tokenization, use a CharStream subclass (see
    above).
  </li>
  <li>
    <A HREF="../../../../org/apache/lucene/analysis/TokenFilter.html" title="class in org.apache.lucene.analysis"><CODE>TokenFilter</CODE></A> &ndash; A TokenFilter is
    also a <A HREF="../../../../org/apache/lucene/analysis/TokenStream.html" title="class in org.apache.lucene.analysis"><CODE>TokenStream</CODE></A> and is responsible
    for modifying tokens that have been created by the Tokenizer.  Common 
    modifications performed by a TokenFilter are: deletion, stemming, synonym 
    injection, and down casing.  Not all Analyzers require TokenFilters.
  </li>
</ul>
<h2>Hints, Tips and Traps</h2>
<p>
  The synergy between <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> and 
  <A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A> is sometimes confusing. To ease
  this confusion, some clarifications:
</p>
<ul>
  <li>
    The <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> is responsible for the entire task of 
    <u>creating</u> tokens out of the input text, while the <A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A>
    is only responsible for <u>breaking</u> the input text into tokens. Very likely, tokens created 
    by the <A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A> would be modified or even omitted 
    by the <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> (via one or more
    <A HREF="../../../../org/apache/lucene/analysis/TokenFilter.html" title="class in org.apache.lucene.analysis"><CODE>TokenFilter</CODE></A>s) before being returned.
  </li>
  <li>
    <A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A> is a <A HREF="../../../../org/apache/lucene/analysis/TokenStream.html" title="class in org.apache.lucene.analysis"><CODE>TokenStream</CODE></A>, 
    but <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> is not.
  </li>
  <li>
    <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis"><CODE>Analyzer</CODE></A> is "field aware", but 
    <A HREF="../../../../org/apache/lucene/analysis/Tokenizer.html" title="class in org.apache.lucene.analysis"><CODE>Tokenizer</CODE></A> is not.
  </li>
</ul>
<p>
  Lucene Java provides a number of analysis capabilities, the most commonly used one being the StandardAnalyzer.  
  Many applications will have a long and industrious life with nothing more
  than the StandardAnalyzer.  However, there are a few other classes/packages that are worth mentioning:
</p>
<ol>
  <li>
    PerFieldAnalyzerWrapper &ndash; Most Analyzers perform the same operation on all
    <A HREF="../../../../org/apache/lucene/document/Field.html" title="class in org.apache.lucene.document"><CODE>Field</CODE></A>s.  The PerFieldAnalyzerWrapper can be used to associate a different Analyzer with different
    <A HREF="../../../../org/apache/lucene/document/Field.html" title="class in org.apache.lucene.document"><CODE>Field</CODE></A>s.
  </li>
  <li>
    The analysis library located at the root of the Lucene distribution has a number of different Analyzer implementations to solve a variety
    of different problems related to searching.  Many of the Analyzers are designed to analyze non-English languages.
  </li>
  <li>
    There are a variety of Tokenizer and TokenFilter implementations in this package.  Take a look around, chances are someone has implemented what you need.
  </li>
</ol>
<p>
  Analysis is one of the main causes of performance degradation during indexing.  Simply put, the more you analyze the slower the indexing (in most cases).
  Perhaps your application would be just fine using the simple WhitespaceTokenizer combined with a StopFilter. The benchmark/ library can be useful 
  for testing out the speed of the analysis process.
</p>
<h2>Invoking the Analyzer</h2>
<p>
  Applications usually do not invoke analysis &ndash; Lucene does it for them:
</p>
<ul>
  <li>
    At indexing, as a consequence of 
    <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addDocument(java.lang.Iterable)"><CODE>addDocument(doc)</CODE></A>,
    the Analyzer in effect for indexing is invoked for each indexed field of the added document.
  </li>
  <li>
    At search, a QueryParser may invoke the Analyzer during parsing.  Note that for some queries, analysis does not
    take place, e.g. wildcard queries.
  </li>
</ul>
<p>
  However an application might invoke Analysis of any text for testing or for any other purpose, something like:
</p>
<PRE class="prettyprint">
    Version matchVersion = Version.LUCENE_XY; // Substitute desired Lucene version for XY
    Analyzer analyzer = new StandardAnalyzer(matchVersion); // or any other analyzer
    TokenStream ts = analyzer.tokenStream("myfield", new StringReader("some text goes here"));
    OffsetAttribute offsetAtt = ts.addAttribute(OffsetAttribute.class);
    
    try {
      ts.reset(); // Resets this stream to the beginning. (Required)
      while (ts.incrementToken()) {
        // Use <A HREF="../../../../org/apache/lucene/util/AttributeSource.html#reflectAsString(boolean)"><CODE>AttributeSource.reflectAsString(boolean)</CODE></A>
        // for token stream debugging.
        System.out.println("token: " + ts.reflectAsString(true));

        System.out.println("token start offset: " + offsetAtt.startOffset());
        System.out.println("  token end offset: " + offsetAtt.endOffset());
      }
      ts.end();   // Perform end-of-stream operations, e.g. set the final offset.
    } finally {
      ts.close(); // Release resources associated with this stream.
    }
</PRE>
<h2>Indexing Analysis vs. Search Analysis</h2>
<p>
  Selecting the "correct" analyzer is crucial
  for search quality, and can also affect indexing and search performance.
  The "correct" analyzer differs between applications.
  Lucene java's wiki page 
  <a href="http://wiki.apache.org/lucene-java/AnalysisParalysis">AnalysisParalysis</a> 
  provides some data on "analyzing your analyzer".
  Here are some rules of thumb:
  <ol>
    <li>Test test test... (did we say test?)</li>
    <li>Beware of over analysis &ndash; might hurt indexing performance.</li>
    <li>Start with same analyzer for indexing and search, otherwise searches would not find what they are supposed to...</li>
    <li>In some cases a different analyzer is required for indexing and search, for instance:
        <ul>
           <li>Certain searches require more stop words to be filtered. (I.e. more than those that were filtered at indexing.)</li>
           <li>Query expansion by synonyms, acronyms, auto spell correction, etc.</li>
        </ul>
        This might sometimes require a modified analyzer &ndash; see the next section on how to do that.
    </li>
  </ol>
</p>
<h2>Implementing your own Analyzer</h2>
<p>
  Creating your own Analyzer is straightforward. Your Analyzer can wrap
  existing analysis components &mdash; CharFilter(s) <i>(optional)</i>, a
  Tokenizer, and TokenFilter(s) <i>(optional)</i> &mdash; or components you
  create, or a combination of existing and newly created components.  Before
  pursuing this approach, you may find it worthwhile to explore the
  <a href="../../../../../analyzers-common/overview-summary.html">analyzers-common</a> library and/or ask on the 
  <a href="http://lucene.apache.org/core/discussion.html"
      >java-user@lucene.apache.org mailing list</a> first to see if what you
  need already exists. If you are still committed to creating your own
  Analyzer, have a look at the source code of any one of the many samples
  located in this package.
</p>
<p>
  The following sections discuss some aspects of implementing your own analyzer.
</p>
<h3>Field Section Boundaries</h3>
<p>
  When <A HREF="../../../../org/apache/lucene/document/Document.html#add(org.apache.lucene.index.IndexableField)"><CODE>document.add(field)</CODE></A>
  is called multiple times for the same field name, we could say that each such call creates a new 
  section for that field in that document. 
  In fact, a separate call to 
  <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html#tokenStream(java.lang.String, java.io.Reader)"><CODE>tokenStream(field,reader)</CODE></A>
  would take place for each of these so called "sections".
  However, the default Analyzer behavior is to treat all these sections as one large section. 
  This allows phrase search and proximity search to seamlessly cross 
  boundaries between these "sections".
  In other words, if a certain field "f" is added like this:
</p>
<PRE class="prettyprint">
    document.add(new Field("f","first ends",...);
    document.add(new Field("f","starts two",...);
    indexWriter.addDocument(document);
</PRE>
<p>
  Then, a phrase search for "ends starts" would find that document.
  Where desired, this behavior can be modified by introducing a "position gap" between consecutive field "sections", 
  simply by overriding 
  <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html#getPositionIncrementGap(java.lang.String)"><CODE>Analyzer.getPositionIncrementGap(fieldName)</CODE></A>:
</p>
<PRE class="prettyprint">
  Version matchVersion = Version.LUCENE_XY; // Substitute desired Lucene version for XY
  Analyzer myAnalyzer = new StandardAnalyzer(matchVersion) {
    public int getPositionIncrementGap(String fieldName) {
      return 10;
    }
  };
</PRE>
<h3>Token Position Increments</h3>
<p>
   By default, all tokens created by Analyzers and Tokenizers have a 
   <A HREF="../../../../org/apache/lucene/analysis/tokenattributes/PositionIncrementAttribute.html#getPositionIncrement()"><CODE>position increment</CODE></A> of one.
   This means that the position stored for that token in the index would be one more than
   that of the previous token.
   Recall that phrase and proximity searches rely on position info.
</p>
<p>
   If the selected analyzer filters the stop words "is" and "the", then for a document 
   containing the string "blue is the sky", only the tokens "blue", "sky" are indexed, 
   with position("sky") = 3 + position("blue"). Now, a phrase query "blue is the sky"
   would find that document, because the same analyzer filters the same stop words from
   that query. But the phrase query "blue sky" would not find that document because the
   position increment between "blue" and "sky" is only 1.
</p>
<p>   
   If this behavior does not fit the application needs, the query parser needs to be
   configured to not take position increments into account when generating phrase queries.
</p>
<p>
  Note that a StopFilter MUST increment the position increment in order not to generate corrupt
  tokenstream graphs. Here is the logic used by StopFilter to increment positions when filtering out tokens:
</p>
<PRE class="prettyprint">
  public TokenStream tokenStream(final String fieldName, Reader reader) {
    final TokenStream ts = someAnalyzer.tokenStream(fieldName, reader);
    TokenStream res = new TokenStream() {
      CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
      PositionIncrementAttribute posIncrAtt = addAttribute(PositionIncrementAttribute.class);

      public boolean incrementToken() throws IOException {
        int extraIncrement = 0;
        while (true) {
          boolean hasNext = ts.incrementToken();
          if (hasNext) {
            if (stopWords.contains(termAtt.toString())) {
              extraIncrement += posIncrAtt.getPositionIncrement(); // filter this word
              continue;
            } 
            if (extraIncrement>0) {
              posIncrAtt.setPositionIncrement(posIncrAtt.getPositionIncrement()+extraIncrement);
            }
          }
          return hasNext;
        }
      }
    };
    return res;
  }
</PRE>
<p>
   A few more use cases for modifying position increments are:
</p>
<ol>
  <li>Inhibiting phrase and proximity matches in sentence boundaries &ndash; for this, a tokenizer that 
    identifies a new sentence can add 1 to the position increment of the first token of the new sentence.</li>
  <li>Injecting synonyms &ndash; here, synonyms of a token should be added after that token, 
    and their position increment should be set to 0.
    As result, all synonyms of a token would be considered to appear in exactly the 
    same position as that token, and so would they be seen by phrase and proximity searches.</li>
</ol>

<h3>Token Position Length</h3>
<p>
   By default, all tokens created by Analyzers and Tokenizers have a
   <A HREF="../../../../org/apache/lucene/analysis/tokenattributes/PositionLengthAttribute.html#getPositionLength()"><CODE>position length</CODE></A> of one.
   This means that the token occupies a single position. This attribute is not indexed
   and thus not taken into account for positional queries, but is used by eg. suggesters.
</p>
<p>
   The main use case for positions lengths is multi-word synonyms. With single-word
   synonyms, setting the position increment to 0 is enough to denote the fact that two
   words are synonyms, for example:
</p>
<table>
<tr><td>Term</td><td>red</td><td>magenta</td></tr>
<tr><td>Position increment</td><td>1</td><td>0</td></tr>
</table>
<p>
   Given that position(magenta) = 0 + position(red), they are at the same position, so anything
   working with analyzers will return the exact same result if you replace "magenta" with "red"
   in the input. However, multi-word synonyms are more tricky. Let's say that you want to build
   a TokenStream where "IBM" is a synonym of "Internal Business Machines". Position increments
   are not enough anymore:
</p>
<table>
<tr><td>Term</td><td>IBM</td><td>International</td><td>Business</td><td>Machines</td></tr>
<tr><td>Position increment</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
</table>
<p>
   The problem with this token stream is that "IBM" is at the same position as "International"
   although it is a synonym with "International Business Machines" as a whole. Setting
   the position increment of "Business" and "Machines" to 0 wouldn't help as it would mean
   than "International" is a synonym of "Business". The only way to solve this issue is to
   make "IBM" span across 3 positions, this is where position lengths come to rescue.
</p>
<table>
<tr><td>Term</td><td>IBM</td><td>International</td><td>Business</td><td>Machines</td></tr>
<tr><td>Position increment</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>Position length</td><td>3</td><td>1</td><td>1</td><td>1</td></tr>
</table>
<p>
   This new attribute makes clear that "IBM" and "International Business Machines" start and end
   at the same positions.
</p>
<a name="corrupt" />
<h3>How to not write corrupt token streams</h3>
<p>
   There are a few rules to observe when writing custom Tokenizers and TokenFilters:
</p>
<ul>
  <li>The first position increment must be &gt; 0.</li>
  <li>Positions must not go backward.</li>
  <li>Tokens that have the same start position must have the same start offset.</li>
  <li>Tokens that have the same end position (taking into account the position length) must have the same end offset.</li>
</ul>
<p>
   Although these rules might seem easy to follow, problems can quickly happen when chaining
   badly implemented filters that play with positions and offsets, such as synonym or n-grams
   filters. Here are good practices for writing correct filters:
</p>
<ul>
  <li>Token filters should not modify offsets. If you feel that your filter would need to modify offsets, then it should probably be implemented as a tokenizer.</li>
  <li>Token filters should not insert positions. If a filter needs to add tokens, then they shoud all have a position increment of 0.</li>
  <li>When they remove tokens, token filters should increment the position increment of the following token.</li>
  <li>Token filters should preserve position lengths.</li>
</ul>
<h2>TokenStream API</h2>
<p>
        "Flexible Indexing" summarizes the effort of making the Lucene indexer
  pluggable and extensible for custom index formats.  A fully customizable
  indexer means that users will be able to store custom data structures on
  disk. Therefore an API is necessary that can transport custom types of
  data from the documents to the indexer.
</p>
<h3>Attribute and AttributeSource</h3>
<p>
  Classes <A HREF="../../../../org/apache/lucene/util/Attribute.html" title="interface in org.apache.lucene.util"><CODE>Attribute</CODE></A> and 
  <A HREF="../../../../org/apache/lucene/util/AttributeSource.html" title="class in org.apache.lucene.util"><CODE>AttributeSource</CODE></A> serve as the basis upon which 
  the analysis elements of "Flexible Indexing" are implemented. An Attribute 
  holds a particular piece of information about a text token. For example, 
  <A HREF="../../../../org/apache/lucene/analysis/tokenattributes/CharTermAttribute.html" title="interface in org.apache.lucene.analysis.tokenattributes"><CODE>CharTermAttribute</CODE></A> 
  contains the term text of a token, and 
  <A HREF="../../../../org/apache/lucene/analysis/tokenattributes/OffsetAttribute.html" title="interface in org.apache.lucene.analysis.tokenattributes"><CODE>OffsetAttribute</CODE></A> contains
  the start and end character offsets of a token. An AttributeSource is a 
  collection of Attributes with a restriction: there may be only one instance
  of each attribute type. TokenStream now extends AttributeSource, which means
  that one can add Attributes to a TokenStream. Since TokenFilter extends
  TokenStream, all filters are also AttributeSources.
</p>
<p>
        Lucene provides seven Attributes out of the box:
</p>
<table rules="all" frame="box" cellpadding="3">
  <tr>
    <td><A HREF="../../../../org/apache/lucene/analysis/tokenattributes/CharTermAttribute.html" title="interface in org.apache.lucene.analysis.tokenattributes"><CODE>CharTermAttribute</CODE></A></td>
    <td>
      The term text of a token.  Implements <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/CharSequence.html?is-external=true" title="class or interface in java.lang"><CODE>CharSequence</CODE></A> 
      (providing methods length() and charAt(), and allowing e.g. for direct
      use with regular expression <A HREF="http://download.oracle.com/javase/6/docs/api/java/util/regex/Matcher.html?is-external=true" title="class or interface in java.util.regex"><CODE>Matcher</CODE></A>s) and 
      <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Appendable.html?is-external=true" title="class or interface in java.lang"><CODE>Appendable</CODE></A> (allowing the term text to be appended to.)
    </td>
  </tr>
  <tr>
    <td><A HREF="../../../../org/apache/lucene/analysis/tokenattributes/OffsetAttribute.html" title="interface in org.apache.lucene.analysis.tokenattributes"><CODE>OffsetAttribute</CODE></A></td>
    <td>The start and end offset of a token in characters.</td>
  </tr>
  <tr>
    <td><A HREF="../../../../org/apache/lucene/analysis/tokenattributes/PositionIncrementAttribute.html" title="interface in org.apache.lucene.analysis.tokenattributes"><CODE>PositionIncrementAttribute</CODE></A></td>
    <td>See above for detailed information about position increment.</td>
  </tr>
  <tr>
    <td><A HREF="../../../../org/apache/lucene/analysis/tokenattributes/PositionLengthAttribute.html" title="interface in org.apache.lucene.analysis.tokenattributes"><CODE>PositionLengthAttribute</CODE></A></td>
    <td>The number of positions occupied by a token.</td>
  </tr>
  <tr>
    <td><A HREF="../../../../org/apache/lucene/analysis/tokenattributes/PayloadAttribute.html" title="interface in org.apache.lucene.analysis.tokenattributes"><CODE>PayloadAttribute</CODE></A></td>
    <td>The payload that a Token can optionally have.</td>
  </tr>
  <tr>
    <td><A HREF="../../../../org/apache/lucene/analysis/tokenattributes/TypeAttribute.html" title="interface in org.apache.lucene.analysis.tokenattributes"><CODE>TypeAttribute</CODE></A></td>
    <td>The type of the token. Default is 'word'.</td>
  </tr>
  <tr>
    <td><A HREF="../../../../org/apache/lucene/analysis/tokenattributes/FlagsAttribute.html" title="interface in org.apache.lucene.analysis.tokenattributes"><CODE>FlagsAttribute</CODE></A></td>
    <td>Optional flags a token can have.</td>
  </tr>
  <tr>
    <td><A HREF="../../../../org/apache/lucene/analysis/tokenattributes/KeywordAttribute.html" title="interface in org.apache.lucene.analysis.tokenattributes"><CODE>KeywordAttribute</CODE></A></td>
    <td>
      Keyword-aware TokenStreams/-Filters skip modification of tokens that
      return true from this attribute's isKeyword() method. 
    </td>
  </tr>
</table>
<h3>Using the TokenStream API</h3>
There are a few important things to know in order to use the new API efficiently which are summarized here. You may want
to walk through the example below first and come back to this section afterwards.
<ol><li>
Please keep in mind that an AttributeSource can only have one instance of a particular Attribute. Furthermore, if 
a chain of a TokenStream and multiple TokenFilters is used, then all TokenFilters in that chain share the Attributes
with the TokenStream.
</li>
<br>
<li>
Attribute instances are reused for all tokens of a document. Thus, a TokenStream/-Filter needs to update
the appropriate Attribute(s) in incrementToken(). The consumer, commonly the Lucene indexer, consumes the data in the
Attributes and then calls incrementToken() again until it returns false, which indicates that the end of the stream
was reached. This means that in each call of incrementToken() a TokenStream/-Filter can safely overwrite the data in
the Attribute instances.
</li>
<br>
<li>
For performance reasons a TokenStream/-Filter should add/get Attributes during instantiation; i.e., create an attribute in the
constructor and store references to it in an instance variable.  Using an instance variable instead of calling addAttribute()/getAttribute() 
in incrementToken() will avoid attribute lookups for every token in the document.
</li>
<br>
<li>
All methods in AttributeSource are idempotent, which means calling them multiple times always yields the same
result. This is especially important to know for addAttribute(). The method takes the <b>type</b> (<code>Class</code>)
of an Attribute as an argument and returns an <b>instance</b>. If an Attribute of the same type was previously added, then
the already existing instance is returned, otherwise a new instance is created and returned. Therefore TokenStreams/-Filters
can safely call addAttribute() with the same Attribute type multiple times. Even consumers of TokenStreams should
normally call addAttribute() instead of getAttribute(), because it would not fail if the TokenStream does not have this
Attribute (getAttribute() would throw an IllegalArgumentException, if the Attribute is missing). More advanced code
could simply check with hasAttribute(), if a TokenStream has it, and may conditionally leave out processing for
extra performance.
</li></ol>
<h3>Example</h3>
<p>
  In this example we will create a WhiteSpaceTokenizer and use a LengthFilter to suppress all words that have
  only two or fewer characters. The LengthFilter is part of the Lucene core and its implementation will be explained
  here to illustrate the usage of the TokenStream API.
</p>
<p>
  Then we will develop a custom Attribute, a PartOfSpeechAttribute, and add another filter to the chain which
  utilizes the new custom attribute, and call it PartOfSpeechTaggingFilter.
</p>
<h4>Whitespace tokenization</h4>
<pre class="prettyprint">
public class MyAnalyzer extends Analyzer {

  private Version matchVersion;
  
  public MyAnalyzer(Version matchVersion) {
    this.matchVersion = matchVersion;
  }

  @Override
  protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
    return new TokenStreamComponents(new WhitespaceTokenizer(matchVersion, reader));
  }
  
  public static void main(String[] args) throws IOException {
    // text to tokenize
    final String text = "This is a demo of the TokenStream API";
    
    Version matchVersion = Version.LUCENE_XY; // Substitute desired Lucene version for XY
    MyAnalyzer analyzer = new MyAnalyzer(matchVersion);
    TokenStream stream = analyzer.tokenStream("field", new StringReader(text));
    
    // get the CharTermAttribute from the TokenStream
    CharTermAttribute termAtt = stream.addAttribute(CharTermAttribute.class);

    try {
      stream.reset();
    
      // print all tokens until stream is exhausted
      while (stream.incrementToken()) {
        System.out.println(termAtt.toString());
      }
    
      stream.end();
    } finally {
      stream.close();
    }
  }
}
</pre>
In this easy example a simple white space tokenization is performed. In main() a loop consumes the stream and
prints the term text of the tokens by accessing the CharTermAttribute that the WhitespaceTokenizer provides. 
Here is the output:
<pre>
This
is
a
demo
of
the
new
TokenStream
API
</pre>
<h4>Adding a LengthFilter</h4>
We want to suppress all tokens that have 2 or less characters. We can do that
easily by adding a LengthFilter to the chain. Only the
<code>createComponents()</code> method in our analyzer needs to be changed:
<pre class="prettyprint">
  @Override
  protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
    final Tokenizer source = new WhitespaceTokenizer(matchVersion, reader);
    TokenStream result = new LengthFilter(true, source, 3, Integer.MAX_VALUE);
    return new TokenStreamComponents(source, result);
  }
</pre>
Note how now only words with 3 or more characters are contained in the output:
<pre>
This
demo
the
new
TokenStream
API
</pre>
Now let's take a look how the LengthFilter is implemented:
<pre class="prettyprint">
public final class LengthFilter extends FilteringTokenFilter {

  private final int min;
  private final int max;
  
  private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);

  /**
   * Create a new LengthFilter. This will filter out tokens whose
   * CharTermAttribute is either too short
   * (&lt; min) or too long (&gt; max).
   * @param version the Lucene match version
   * @param in      the TokenStream to consume
   * @param min     the minimum length
   * @param max     the maximum length
   */
  public LengthFilter(Version version, TokenStream in, int min, int max) {
    super(version, in);
    this.min = min;
    this.max = max;
  }

  @Override
  public boolean accept() {
    final int len = termAtt.length();
    return (len &gt;= min &amp;&amp; len <= max);
  }

}
</pre>
<p>
  In LengthFilter, the CharTermAttribute is added and stored in the instance
  variable <code>termAtt</code>.  Remember that there can only be a single
  instance of CharTermAttribute in the chain, so in our example the
  <code>addAttribute()</code> call in LengthFilter returns the
  CharTermAttribute that the WhitespaceTokenizer already added.
</p>
<p>
  The tokens are retrieved from the input stream in FilteringTokenFilter's 
  <code>incrementToken()</code> method (see below), which calls LengthFilter's
  <code>accept()</code> method. By looking at the term text in the
  CharTermAttribute, the length of the term can be determined and tokens that
  are either too short or too long are skipped.  Note how
  <code>accept()</code> can efficiently access the instance variable; no 
  attribute lookup is necessary. The same is true for the consumer, which can
  simply use local references to the Attributes.
</p>
<p>
  LengthFilter extends FilteringTokenFilter:
</p>

<pre class="prettyprint">
public abstract class FilteringTokenFilter extends TokenFilter {

  private final PositionIncrementAttribute posIncrAtt = addAttribute(PositionIncrementAttribute.class);

  /**
   * Create a new FilteringTokenFilter.
   * @param in      the TokenStream to consume
   */
  public FilteringTokenFilter(Version version, TokenStream in) {
    super(in);
  }

  /** Override this method and return if the current input token should be returned by incrementToken. */
  protected abstract boolean accept() throws IOException;

  @Override
  public final boolean incrementToken() throws IOException {
    int skippedPositions = 0;
    while (input.incrementToken()) {
      if (accept()) {
        if (skippedPositions != 0) {
          posIncrAtt.setPositionIncrement(posIncrAtt.getPositionIncrement() + skippedPositions);
        }
        return true;
      }
      skippedPositions += posIncrAtt.getPositionIncrement();
    }
    // reached EOS -- return false
    return false;
  }

  @Override
  public void reset() throws IOException {
    super.reset();
  }

}
</pre>

<h4>Adding a custom Attribute</h4>
Now we're going to implement our own custom Attribute for part-of-speech tagging and call it consequently 
<code>PartOfSpeechAttribute</code>. First we need to define the interface of the new Attribute:
<pre class="prettyprint">
  public interface PartOfSpeechAttribute extends Attribute {
    public static enum PartOfSpeech {
      Noun, Verb, Adjective, Adverb, Pronoun, Preposition, Conjunction, Article, Unknown
    }
  
    public void setPartOfSpeech(PartOfSpeech pos);
  
    public PartOfSpeech getPartOfSpeech();
  }
</pre>
<p>
  Now we also need to write the implementing class. The name of that class is important here: By default, Lucene
  checks if there is a class with the name of the Attribute with the suffix 'Impl'. In this example, we would
  consequently call the implementing class <code>PartOfSpeechAttributeImpl</code>.
</p>
<p>
  This should be the usual behavior. However, there is also an expert-API that allows changing these naming conventions:
  <A HREF="../../../../org/apache/lucene/util/AttributeSource.AttributeFactory.html" title="class in org.apache.lucene.util"><CODE>AttributeSource.AttributeFactory</CODE></A>. The factory accepts an Attribute interface as argument
  and returns an actual instance. You can implement your own factory if you need to change the default behavior.
</p>
<p>
  Now here is the actual class that implements our new Attribute. Notice that the class has to extend
  <A HREF="../../../../org/apache/lucene/util/AttributeImpl.html" title="class in org.apache.lucene.util"><CODE>AttributeImpl</CODE></A>:
</p>
<pre class="prettyprint">
public final class PartOfSpeechAttributeImpl extends AttributeImpl 
                                  implements PartOfSpeechAttribute {
  
  private PartOfSpeech pos = PartOfSpeech.Unknown;
  
  public void setPartOfSpeech(PartOfSpeech pos) {
    this.pos = pos;
  }
  
  public PartOfSpeech getPartOfSpeech() {
    return pos;
  }

  @Override
  public void clear() {
    pos = PartOfSpeech.Unknown;
  }

  @Override
  public void copyTo(AttributeImpl target) {
    ((PartOfSpeechAttribute) target).setPartOfSpeech(pos);
  }
}
</pre>
<p>
  This is a simple Attribute implementation has only a single variable that
  stores the part-of-speech of a token. It extends the
  <code>AttributeImpl</code> class and therefore implements its abstract methods
  <code>clear()</code> and <code>copyTo()</code>. Now we need a TokenFilter that
  can set this new PartOfSpeechAttribute for each token. In this example we
  show a very naive filter that tags every word with a leading upper-case letter
  as a 'Noun' and all other words as 'Unknown'.
</p>
<pre class="prettyprint">
  public static class PartOfSpeechTaggingFilter extends TokenFilter {
    PartOfSpeechAttribute posAtt = addAttribute(PartOfSpeechAttribute.class);
    CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
    
    protected PartOfSpeechTaggingFilter(TokenStream input) {
      super(input);
    }
    
    public boolean incrementToken() throws IOException {
      if (!input.incrementToken()) {return false;}
      posAtt.setPartOfSpeech(determinePOS(termAtt.buffer(), 0, termAtt.length()));
      return true;
    }
    
    // determine the part of speech for the given term
    protected PartOfSpeech determinePOS(char[] term, int offset, int length) {
      // naive implementation that tags every uppercased word as noun
      if (length > 0 && Character.isUpperCase(term[0])) {
        return PartOfSpeech.Noun;
      }
      return PartOfSpeech.Unknown;
    }
  }
</pre>
<p>
  Just like the LengthFilter, this new filter stores references to the
  attributes it needs in instance variables. Notice how you only need to pass
  in the interface of the new Attribute and instantiating the correct class
  is automatically taken care of.
</p>
<p>Now we need to add the filter to the chain in MyAnalyzer:</p>
<pre class="prettyprint">
  @Override
  protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
    final Tokenizer source = new WhitespaceTokenizer(matchVersion, reader);
    TokenStream result = new LengthFilter(true, source, 3, Integer.MAX_VALUE);
    result = new PartOfSpeechTaggingFilter(result);
    return new TokenStreamComponents(source, result);
  }
</pre>
Now let's look at the output:
<pre>
This
demo
the
new
TokenStream
API
</pre>
Apparently it hasn't changed, which shows that adding a custom attribute to a TokenStream/Filter chain does not
affect any existing consumers, simply because they don't know the new Attribute. Now let's change the consumer
to make use of the new PartOfSpeechAttribute and print it out:
<pre class="prettyprint">
  public static void main(String[] args) throws IOException {
    // text to tokenize
    final String text = "This is a demo of the TokenStream API";
    
    MyAnalyzer analyzer = new MyAnalyzer();
    TokenStream stream = analyzer.tokenStream("field", new StringReader(text));
    
    // get the CharTermAttribute from the TokenStream
    CharTermAttribute termAtt = stream.addAttribute(CharTermAttribute.class);
    
    // get the PartOfSpeechAttribute from the TokenStream
    PartOfSpeechAttribute posAtt = stream.addAttribute(PartOfSpeechAttribute.class);

    try {
      stream.reset();

      // print all tokens until stream is exhausted
      while (stream.incrementToken()) {
        System.out.println(termAtt.toString() + ": " + posAtt.getPartOfSpeech());
      }
    
      stream.end();
    } finally {
      stream.close();
    }
  }
</pre>
The change that was made is to get the PartOfSpeechAttribute from the TokenStream and print out its contents in
the while loop that consumes the stream. Here is the new output:
<pre>
This: Noun
demo: Unknown
the: Unknown
new: Unknown
TokenStream: Noun
API: Noun
</pre>
Each word is now followed by its assigned PartOfSpeech tag. Of course this is a naive 
part-of-speech tagging. The word 'This' should not even be tagged as noun; it is only spelled capitalized because it
is the first word of a sentence. Actually this is a good opportunity for an exercise. To practice the usage of the new
API the reader could now write an Attribute and TokenFilter that can specify for each word if it was the first token
of a sentence or not. Then the PartOfSpeechTaggingFilter can make use of this knowledge and only tag capitalized words
as nouns if not the first word of a sentence (we know, this is still not a correct behavior, but hey, it's a good exercise). 
As a small hint, this is how the new Attribute class could begin:
<pre class="prettyprint">
  public class FirstTokenOfSentenceAttributeImpl extends AttributeImpl
                              implements FirstTokenOfSentenceAttribute {
    
    private boolean firstToken;
    
    public void setFirstToken(boolean firstToken) {
      this.firstToken = firstToken;
    }
    
    public boolean getFirstToken() {
      return firstToken;
    }

    @Override
    public void clear() {
      firstToken = false;
    }

  ...
</pre>
<h4>Adding a CharFilter chain</h4>
Analyzers take Java <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/Reader.html?is-external=true" title="class or interface in java.io"><CODE>Reader</CODE></A>s as input. Of course you can wrap your Readers with <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/FilterReader.html?is-external=true" title="class or interface in java.io"><CODE>FilterReader</CODE></A>s
to manipulate content, but this would have the big disadvantage that character offsets might be inconsistent with your original
text.
<p>
<A HREF="../../../../org/apache/lucene/analysis/CharFilter.html" title="class in org.apache.lucene.analysis"><CODE>CharFilter</CODE></A> is designed to allow you to pre-process input like a FilterReader would, but also
preserve the original offsets associated with those characters. This way mechanisms like highlighting still work correctly.
CharFilters can be chained.
<p>
Example:
<pre class="prettyprint">
public class MyAnalyzer extends Analyzer {

  @Override
  protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
    return new TokenStreamComponents(new MyTokenizer(reader));
  }
  
  @Override
  protected Reader initReader(String fieldName, Reader reader) {
    // wrap the Reader in a CharFilter chain.
    return new SecondCharFilter(new FirstCharFilter(reader));
  }
}
</pre>
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/lucene/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/lucene/analysis/tokenattributes/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/apache/lucene/analysis/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

          <i>Copyright &copy; 2000-2013 Apache Software Foundation.  All Rights Reserved.</i>
          <script src='../../../../prettify.js' type='text/javascript'></script>
          <script type='text/javascript'>
            (function(){
              var oldonload = window.onload;
              if (typeof oldonload != 'function') {
                window.onload = prettyPrint;
              } else {
                window.onload = function() {
                  oldonload();
                  prettyPrint();
                }
              }
            })();
          </script>
        
</BODY>
</HTML>
