<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_45) on Sat Sep 28 14:03:25 CEST 2013 -->
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<TITLE>
IndexWriter (Lucene 4.5.0 API)
</TITLE>

<META NAME="date" CONTENT="2013-09-28">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="IndexWriter (Lucene 4.5.0 API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/IndexWriter.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/lucene/index/IndexUpgrader.html" title="class in org.apache.lucene.index"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/lucene/index/IndexWriter.IndexReaderWarmer.html" title="class in org.apache.lucene.index"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/apache/lucene/index/IndexWriter.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="IndexWriter.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.apache.lucene.index</FONT>
<BR>
Class IndexWriter</H2>
<PRE>
<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><B>org.apache.lucene.index.IndexWriter</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/Closeable.html?is-external=true" title="class or interface in java.io">Closeable</A>, <A HREF="../../../../org/apache/lucene/index/TwoPhaseCommit.html" title="interface in org.apache.lucene.index">TwoPhaseCommit</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>IndexWriter</B><DT>extends <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A><DT>implements <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/Closeable.html?is-external=true" title="class or interface in java.io">Closeable</A>, <A HREF="../../../../org/apache/lucene/index/TwoPhaseCommit.html" title="interface in org.apache.lucene.index">TwoPhaseCommit</A></DL>
</PRE>

<P>
An <code>IndexWriter</code> creates and maintains an index.

  <p>The <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.OpenMode.html" title="enum in org.apache.lucene.index"><CODE>IndexWriterConfig.OpenMode</CODE></A> option on 
  <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.html#setOpenMode(org.apache.lucene.index.IndexWriterConfig.OpenMode)"><CODE>IndexWriterConfig.setOpenMode(OpenMode)</CODE></A> determines 
  whether a new index is created, or whether an existing index is
  opened. Note that you can open an index with <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.OpenMode.html#CREATE"><CODE>IndexWriterConfig.OpenMode.CREATE</CODE></A>
  even while readers are using the index. The old readers will 
  continue to search the "point in time" snapshot they had opened, 
  and won't see the newly created index until they re-open. If 
  <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.OpenMode.html#CREATE_OR_APPEND"><CODE>IndexWriterConfig.OpenMode.CREATE_OR_APPEND</CODE></A> is used IndexWriter will create a 
  new index if there is not already an index at the provided path
  and otherwise open the existing index.</p>

  <p>In either case, documents are added with <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addDocument(java.lang.Iterable)"><CODE>addDocument</CODE></A> and removed with <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteDocuments(org.apache.lucene.index.Term)"><CODE>deleteDocuments(Term)</CODE></A> or <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteDocuments(org.apache.lucene.search.Query)"><CODE>deleteDocuments(Query)</CODE></A>. A document can be updated with <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#updateDocument(org.apache.lucene.index.Term, java.lang.Iterable)"><CODE>updateDocument</CODE></A> (which just deletes
  and then adds the entire document). When finished adding, deleting 
  and updating documents, <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#close()"><CODE>close</CODE></A> should be called.</p>

  <a name="flush"></a>
  <p>These changes are buffered in memory and periodically
  flushed to the <A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store"><CODE>Directory</CODE></A> (during the above method
  calls). A flush is triggered when there are enough added documents
  since the last flush. Flushing is triggered either by RAM usage of the
  documents (see <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.html#setRAMBufferSizeMB(double)"><CODE>IndexWriterConfig.setRAMBufferSizeMB(double)</CODE></A>) or the
  number of added documents (see <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.html#setMaxBufferedDocs(int)"><CODE>IndexWriterConfig.setMaxBufferedDocs(int)</CODE></A>).
  The default is to flush when RAM usage hits
  <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.html#DEFAULT_RAM_BUFFER_SIZE_MB"><CODE>IndexWriterConfig.DEFAULT_RAM_BUFFER_SIZE_MB</CODE></A> MB. For
  best indexing speed you should flush by RAM usage with a
  large RAM buffer. Additionally, if IndexWriter reaches the configured number of
  buffered deletes (see <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.html#setMaxBufferedDeleteTerms(int)"><CODE>IndexWriterConfig.setMaxBufferedDeleteTerms(int)</CODE></A>)
  the deleted terms and queries are flushed and applied to existing segments.
  In contrast to the other flush options <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.html#setRAMBufferSizeMB(double)"><CODE>IndexWriterConfig.setRAMBufferSizeMB(double)</CODE></A> and 
  <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.html#setMaxBufferedDocs(int)"><CODE>IndexWriterConfig.setMaxBufferedDocs(int)</CODE></A>, deleted terms
  won't trigger a segment flush. Note that flushing just moves the
  internal buffered state in IndexWriter into the index, but
  these changes are not visible to IndexReader until either
  <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#commit()"><CODE>commit()</CODE></A> or <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#close()"><CODE>close()</CODE></A> is called.  A flush may
  also trigger one or more segment merges which by default
  run with a background thread so as not to block the
  addDocument calls (see <a href="#mergePolicy">below</a>
  for changing the <A HREF="../../../../org/apache/lucene/index/MergeScheduler.html" title="class in org.apache.lucene.index"><CODE>MergeScheduler</CODE></A>).</p>

  <p>Opening an <code>IndexWriter</code> creates a lock file for the directory in use. Trying to open
  another <code>IndexWriter</code> on the same directory will lead to a
  <A HREF="../../../../org/apache/lucene/store/LockObtainFailedException.html" title="class in org.apache.lucene.store"><CODE>LockObtainFailedException</CODE></A>. The <A HREF="../../../../org/apache/lucene/store/LockObtainFailedException.html" title="class in org.apache.lucene.store"><CODE>LockObtainFailedException</CODE></A>
  is also thrown if an IndexReader on the same directory is used to delete documents
  from the index.</p>

  <a name="deletionPolicy"></a>
  <p>Expert: <code>IndexWriter</code> allows an optional
  <A HREF="../../../../org/apache/lucene/index/IndexDeletionPolicy.html" title="class in org.apache.lucene.index"><CODE>IndexDeletionPolicy</CODE></A> implementation to be
  specified.  You can use this to control when prior commits
  are deleted from the index.  The default policy is <A HREF="../../../../org/apache/lucene/index/KeepOnlyLastCommitDeletionPolicy.html" title="class in org.apache.lucene.index"><CODE>KeepOnlyLastCommitDeletionPolicy</CODE></A> which removes all prior
  commits as soon as a new commit is done (this matches
  behavior before 2.2).  Creating your own policy can allow
  you to explicitly keep previous "point in time" commits
  alive in the index for some time, to allow readers to
  refresh to the new commit without having the old commit
  deleted out from under them.  This is necessary on
  filesystems like NFS that do not support "delete on last
  close" semantics, which Lucene's "point in time" search
  normally relies on. </p>

  <a name="mergePolicy"></a> <p>Expert:
  <code>IndexWriter</code> allows you to separately change
  the <A HREF="../../../../org/apache/lucene/index/MergePolicy.html" title="class in org.apache.lucene.index"><CODE>MergePolicy</CODE></A> and the <A HREF="../../../../org/apache/lucene/index/MergeScheduler.html" title="class in org.apache.lucene.index"><CODE>MergeScheduler</CODE></A>.
  The <A HREF="../../../../org/apache/lucene/index/MergePolicy.html" title="class in org.apache.lucene.index"><CODE>MergePolicy</CODE></A> is invoked whenever there are
  changes to the segments in the index.  Its role is to
  select which merges to do, if any, and return a <A HREF="../../../../org/apache/lucene/index/MergePolicy.MergeSpecification.html" title="class in org.apache.lucene.index"><CODE>MergePolicy.MergeSpecification</CODE></A> describing the merges.
  The default is <A HREF="../../../../org/apache/lucene/index/LogByteSizeMergePolicy.html" title="class in org.apache.lucene.index"><CODE>LogByteSizeMergePolicy</CODE></A>.  Then, the <A HREF="../../../../org/apache/lucene/index/MergeScheduler.html" title="class in org.apache.lucene.index"><CODE>MergeScheduler</CODE></A> is invoked with the requested merges and
  it decides when and how to run the merges.  The default is
  <A HREF="../../../../org/apache/lucene/index/ConcurrentMergeScheduler.html" title="class in org.apache.lucene.index"><CODE>ConcurrentMergeScheduler</CODE></A>. </p>

  <a name="OOME"></a><p><b>NOTE</b>: if you hit an
  OutOfMemoryError then IndexWriter will quietly record this
  fact and block all future segment commits.  This is a
  defensive measure in case any internal state (buffered
  documents and deletions) were corrupted.  Any subsequent
  calls to <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#commit()"><CODE>commit()</CODE></A> will throw an
  IllegalStateException.  The only course of action is to
  call <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#close()"><CODE>close()</CODE></A>, which internally will call <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#rollback()"><CODE>rollback()</CODE></A>, to undo any changes to the index since the
  last commit.  You can also just call <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#rollback()"><CODE>rollback()</CODE></A>
  directly.</p>

  <a name="thread-safety"></a><p><b>NOTE</b>: <A HREF="../../../../org/apache/lucene/index/IndexWriter.html" title="class in org.apache.lucene.index"><CODE>IndexWriter</CODE></A> instances are completely thread
  safe, meaning multiple threads can call any of its
  methods, concurrently.  If your application requires
  external synchronization, you should <b>not</b>
  synchronize on the <code>IndexWriter</code> instance as
  this may cause deadlock; use your own (non-Lucene) objects
  instead. </p>

  <p><b>NOTE</b>: If you call
  <code>Thread.interrupt()</code> on a thread that's within
  IndexWriter, IndexWriter will try to catch this (eg, if
  it's in a wait() or Thread.sleep()), and will then throw
  the unchecked exception <A HREF="../../../../org/apache/lucene/util/ThreadInterruptedException.html" title="class in org.apache.lucene.util"><CODE>ThreadInterruptedException</CODE></A>
  and <b>clear</b> the interrupt status on the thread.</p>
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.IndexReaderWarmer.html" title="class in org.apache.lucene.index">IndexWriter.IndexReaderWarmer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If <A HREF="../../../../org/apache/lucene/index/DirectoryReader.html#open(org.apache.lucene.index.IndexWriter, boolean)"><CODE>DirectoryReader.open(IndexWriter,boolean)</CODE></A> has
  been called (ie, this writer is in near real-time
  mode), then after a merge completes, this class can be
  invoked to warm the reader on the newly merged
  segment, before the merge commits.</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#MAX_TERM_LENGTH">MAX_TERM_LENGTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Absolute hard maximum length for a term, in bytes once
 encoded as UTF8.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#SOURCE">SOURCE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key for the source of a segment in the <A HREF="../../../../org/apache/lucene/index/SegmentInfo.html#getDiagnostics()"><CODE>diagnostics</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#SOURCE_ADDINDEXES_READERS">SOURCE_ADDINDEXES_READERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source of a segment which results from a call to <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addIndexes(org.apache.lucene.index.IndexReader...)"><CODE>addIndexes(IndexReader...)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#SOURCE_FLUSH">SOURCE_FLUSH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source of a segment which results from a flush.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#SOURCE_MERGE">SOURCE_MERGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source of a segment which results from a merge of other segments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#WRITE_LOCK_NAME">WRITE_LOCK_NAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name of the write lock in the index.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#IndexWriter(org.apache.lucene.store.Directory, org.apache.lucene.index.IndexWriterConfig)">IndexWriter</A></B>(<A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store">Directory</A>&nbsp;d,
            <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.html" title="class in org.apache.lucene.index">IndexWriterConfig</A>&nbsp;conf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a new IndexWriter per the settings given in <code>conf</code>.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addDocument(java.lang.Iterable)">addDocument</A></B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&nbsp;doc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a document to this index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addDocument(java.lang.Iterable, org.apache.lucene.analysis.Analyzer)">addDocument</A></B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&nbsp;doc,
            <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A>&nbsp;analyzer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a document to this index, using the provided analyzer instead of the
 value of <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#getAnalyzer()"><CODE>getAnalyzer()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addDocuments(java.lang.Iterable)">addDocuments</A></B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&gt;&nbsp;docs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomically adds a block of documents with sequentially
 assigned document IDs, such that an external reader
 will see all or none of the documents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addDocuments(java.lang.Iterable, org.apache.lucene.analysis.Analyzer)">addDocuments</A></B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&gt;&nbsp;docs,
             <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A>&nbsp;analyzer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomically adds a block of documents, analyzed using the
 provided analyzer, with sequentially assigned document
 IDs, such that an external reader will see all or none
 of the documents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addIndexes(org.apache.lucene.store.Directory...)">addIndexes</A></B>(<A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store">Directory</A>...&nbsp;dirs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds all segments from an array of indexes into this index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addIndexes(org.apache.lucene.index.IndexReader...)">addIndexes</A></B>(<A HREF="../../../../org/apache/lucene/index/IndexReader.html" title="class in org.apache.lucene.index">IndexReader</A>...&nbsp;readers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merges the provided indexes into this index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commits all changes to an index, waits for pending merges
 to complete, and closes all associated files.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#close(boolean)">close</A></B>(boolean&nbsp;waitForMerges)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closes the index with or without waiting for currently
 running merges to finish.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#commit()">commit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commits all pending changes (added & deleted
 documents, segment merges, added
 indexes, etc.) to the index, and syncs all referenced
 index files, such that a reader will see the changes
 and the index updates will survive an OS or machine
 crash or power loss.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteAll()">deleteAll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete all documents in the index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteDocuments(org.apache.lucene.search.Query...)">deleteDocuments</A></B>(<A HREF="../../../../org/apache/lucene/search/Query.html" title="class in org.apache.lucene.search">Query</A>...&nbsp;queries)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deletes the document(s) matching any of the provided queries.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteDocuments(org.apache.lucene.search.Query)">deleteDocuments</A></B>(<A HREF="../../../../org/apache/lucene/search/Query.html" title="class in org.apache.lucene.search">Query</A>&nbsp;query)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deletes the document(s) matching the provided query.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteDocuments(org.apache.lucene.index.Term...)">deleteDocuments</A></B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>...&nbsp;terms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deletes the document(s) containing any of the
 terms.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteDocuments(org.apache.lucene.index.Term)">deleteDocuments</A></B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>&nbsp;term)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deletes the document(s) containing <code>term</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteUnusedFiles()">deleteUnusedFiles</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expert: remove any index files that are no longer
  used.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#doAfterFlush()">doAfterFlush</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A hook for extending classes to execute operations after pending added and
 deleted documents have been flushed to the Directory but before the change
 is committed (new segments_N file written).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#doBeforeFlush()">doBeforeFlush</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A hook for extending classes to execute operations before pending added and
 deleted documents are flushed to the Directory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#ensureOpen()">ensureOpen</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used internally to throw an <A HREF="../../../../org/apache/lucene/store/AlreadyClosedException.html" title="class in org.apache.lucene.store"><CODE>AlreadyClosedException</CODE></A> if this IndexWriter has been
 closed (<code>closed=true</code>) or is in the process of
 closing (<code>closing=true</code>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#ensureOpen(boolean)">ensureOpen</A></B>(boolean&nbsp;failIfClosing)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used internally to throw an <A HREF="../../../../org/apache/lucene/store/AlreadyClosedException.html" title="class in org.apache.lucene.store"><CODE>AlreadyClosedException</CODE></A> if this
 IndexWriter has been closed or is in the process of closing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#flush(boolean, boolean)">flush</A></B>(boolean&nbsp;triggerMerge,
      boolean&nbsp;applyAllDeletes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flush all in-memory buffered updates (adds and deletes)
 to the Directory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMerge(int)">forceMerge</A></B>(int&nbsp;maxNumSegments)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forces merge policy to merge segments until there are <=
 maxNumSegments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMerge(int, boolean)">forceMerge</A></B>(int&nbsp;maxNumSegments,
           boolean&nbsp;doWait)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Just like <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMerge(int)"><CODE>forceMerge(int)</CODE></A>, except you can
  specify whether the call should block until
  all merging completes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMergeDeletes()">forceMergeDeletes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forces merging of all segments that have deleted
  documents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMergeDeletes(boolean)">forceMergeDeletes</A></B>(boolean&nbsp;doWait)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Just like <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMergeDeletes()"><CODE>forceMergeDeletes()</CODE></A>, except you can
  specify whether the call should block until the
  operation completes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#getAnalyzer()">getAnalyzer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the analyzer used by this index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>,<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#getCommitData()">getCommitData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the commit user data map that was last committed, or the one that
 was set on <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#setCommitData(java.util.Map)"><CODE>setCommitData(Map)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/lucene/index/LiveIndexWriterConfig.html" title="class in org.apache.lucene.index">LiveIndexWriterConfig</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#getConfig()">getConfig</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <A HREF="../../../../org/apache/lucene/index/LiveIndexWriterConfig.html" title="class in org.apache.lucene.index"><CODE>LiveIndexWriterConfig</CODE></A>, which can be used to query the IndexWriter
 current settings, as well as modify "live" ones.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store">Directory</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#getDirectory()">getDirectory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Directory used by this index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../org/apache/lucene/index/SegmentInfoPerCommit.html" title="class in org.apache.lucene.index">SegmentInfoPerCommit</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#getMergingSegments()">getMergingSegments</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expert: to be used by a <A HREF="../../../../org/apache/lucene/index/MergePolicy.html" title="class in org.apache.lucene.index"><CODE>MergePolicy</CODE></A> to avoid
  selecting merges for segments already being merged.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../org/apache/lucene/index/MergePolicy.OneMerge.html" title="class in org.apache.lucene.index">MergePolicy.OneMerge</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#getNextMerge()">getNextMerge</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expert: the <A HREF="../../../../org/apache/lucene/index/MergeScheduler.html" title="class in org.apache.lucene.index"><CODE>MergeScheduler</CODE></A> calls this method to retrieve the next
 merge requested by the MergePolicy</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#hasDeletions()">hasDeletions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if this index has deletions (including buffered deletions).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#hasPendingMerges()">hasPendingMerges</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expert: returns true if there are merges waiting to be scheduled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#hasUncommittedChanges()">hasUncommittedChanges</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if there are changes that have not been committed</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#isLocked(org.apache.lucene.store.Directory)">isLocked</A></B>(<A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store">Directory</A>&nbsp;directory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> iff the index in the named directory is
 currently locked.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#maxDoc()">maxDoc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns total number of docs in this index, including
  docs not yet flushed (still in the RAM buffer),
  not counting deletions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#maybeMerge()">maybeMerge</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expert: asks the mergePolicy whether any merges are
 necessary now and if so, runs the requested merges and
 then iterate (test again if merges are needed) until no
 more merges are returned by the mergePolicy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#merge(org.apache.lucene.index.MergePolicy.OneMerge)">merge</A></B>(<A HREF="../../../../org/apache/lucene/index/MergePolicy.OneMerge.html" title="class in org.apache.lucene.index">MergePolicy.OneMerge</A>&nbsp;merge)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merges the indicated segments, replacing them in the stack with a
 single segment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#numDeletedDocs(org.apache.lucene.index.SegmentInfoPerCommit)">numDeletedDocs</A></B>(<A HREF="../../../../org/apache/lucene/index/SegmentInfoPerCommit.html" title="class in org.apache.lucene.index">SegmentInfoPerCommit</A>&nbsp;info)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtain the number of deleted docs for a pooled reader.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#numDocs()">numDocs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns total number of docs in this index, including
  docs not yet flushed (still in the RAM buffer), and
  including deletions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#numRamDocs()">numRamDocs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expert:  Return the number of documents currently
  buffered in RAM.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#prepareCommit()">prepareCommit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expert: prepare for commit.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#ramSizeInBytes()">ramSizeInBytes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expert:  Return the total size of all index files currently cached in memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#rollback()">rollback</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Close the <code>IndexWriter</code> without committing
 any changes that have occurred since the last commit
 (or since it was opened, if commit hasn't been called).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#segString()">segString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string description of all segments, for
  debugging.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#segString(java.lang.Iterable)">segString</A></B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;<A HREF="../../../../org/apache/lucene/index/SegmentInfoPerCommit.html" title="class in org.apache.lucene.index">SegmentInfoPerCommit</A>&gt;&nbsp;infos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string description of the specified
  segments, for debugging.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#segString(org.apache.lucene.index.SegmentInfoPerCommit)">segString</A></B>(<A HREF="../../../../org/apache/lucene/index/SegmentInfoPerCommit.html" title="class in org.apache.lucene.index">SegmentInfoPerCommit</A>&nbsp;info)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string description of the specified
  segment, for debugging.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#setCommitData(java.util.Map)">setCommitData</A></B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>,<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&gt;&nbsp;commitUserData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the commit user data map.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#tryDeleteDocument(org.apache.lucene.index.IndexReader, int)">tryDeleteDocument</A></B>(<A HREF="../../../../org/apache/lucene/index/IndexReader.html" title="class in org.apache.lucene.index">IndexReader</A>&nbsp;readerIn,
                  int&nbsp;docID)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expert: attempts to delete by document ID, as long as
  the provided reader is a near-real-time reader (from <A HREF="../../../../org/apache/lucene/index/DirectoryReader.html#open(org.apache.lucene.index.IndexWriter, boolean)"><CODE>DirectoryReader.open(IndexWriter,boolean)</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#unlock(org.apache.lucene.store.Directory)">unlock</A></B>(<A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store">Directory</A>&nbsp;directory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forcibly unlocks the index in the named directory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#updateDocument(org.apache.lucene.index.Term, java.lang.Iterable)">updateDocument</A></B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>&nbsp;term,
               <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&nbsp;doc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updates a document by first deleting the document(s)
 containing <code>term</code> and then adding the new
 document.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#updateDocument(org.apache.lucene.index.Term, java.lang.Iterable, org.apache.lucene.analysis.Analyzer)">updateDocument</A></B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>&nbsp;term,
               <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&nbsp;doc,
               <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A>&nbsp;analyzer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updates a document by first deleting the document(s)
 containing <code>term</code> and then adding the new
 document.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#updateDocuments(org.apache.lucene.index.Term, java.lang.Iterable)">updateDocuments</A></B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>&nbsp;delTerm,
                <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&gt;&nbsp;docs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomically deletes documents matching the provided
 delTerm and adds a block of documents with sequentially
 assigned document IDs, such that an external reader
 will see all or none of the documents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#updateDocuments(org.apache.lucene.index.Term, java.lang.Iterable, org.apache.lucene.analysis.Analyzer)">updateDocuments</A></B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>&nbsp;delTerm,
                <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&gt;&nbsp;docs,
                <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A>&nbsp;analyzer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomically deletes documents matching the provided
 delTerm and adds a block of documents, analyzed  using
 the provided analyzer, with sequentially
 assigned document IDs, such that an external reader
 will see all or none of the documents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#waitForMerges()">waitForMerges</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait for any currently outstanding merges to finish.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="WRITE_LOCK_NAME"><!-- --></A><H3>
WRITE_LOCK_NAME</H3>
<PRE>
public static final <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>WRITE_LOCK_NAME</B></PRE>
<DL>
<DD>Name of the write lock in the index.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#org.apache.lucene.index.IndexWriter.WRITE_LOCK_NAME">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SOURCE"><!-- --></A><H3>
SOURCE</H3>
<PRE>
public static final <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>SOURCE</B></PRE>
<DL>
<DD>Key for the source of a segment in the <A HREF="../../../../org/apache/lucene/index/SegmentInfo.html#getDiagnostics()"><CODE>diagnostics</CODE></A>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#org.apache.lucene.index.IndexWriter.SOURCE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SOURCE_MERGE"><!-- --></A><H3>
SOURCE_MERGE</H3>
<PRE>
public static final <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>SOURCE_MERGE</B></PRE>
<DL>
<DD>Source of a segment which results from a merge of other segments.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#org.apache.lucene.index.IndexWriter.SOURCE_MERGE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SOURCE_FLUSH"><!-- --></A><H3>
SOURCE_FLUSH</H3>
<PRE>
public static final <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>SOURCE_FLUSH</B></PRE>
<DL>
<DD>Source of a segment which results from a flush.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#org.apache.lucene.index.IndexWriter.SOURCE_FLUSH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SOURCE_ADDINDEXES_READERS"><!-- --></A><H3>
SOURCE_ADDINDEXES_READERS</H3>
<PRE>
public static final <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>SOURCE_ADDINDEXES_READERS</B></PRE>
<DL>
<DD>Source of a segment which results from a call to <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addIndexes(org.apache.lucene.index.IndexReader...)"><CODE>addIndexes(IndexReader...)</CODE></A>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#org.apache.lucene.index.IndexWriter.SOURCE_ADDINDEXES_READERS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MAX_TERM_LENGTH"><!-- --></A><H3>
MAX_TERM_LENGTH</H3>
<PRE>
public static final int <B>MAX_TERM_LENGTH</B></PRE>
<DL>
<DD>Absolute hard maximum length for a term, in bytes once
 encoded as UTF8.  If a term arrives from the analyzer
 longer than this length, it is skipped and a message is
 printed to infoStream, if set (see <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.html#setInfoStream(org.apache.lucene.util.InfoStream)"><CODE>IndexWriterConfig.setInfoStream(InfoStream)</CODE></A>).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#org.apache.lucene.index.IndexWriter.MAX_TERM_LENGTH">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="IndexWriter(org.apache.lucene.store.Directory, org.apache.lucene.index.IndexWriterConfig)"><!-- --></A><H3>
IndexWriter</H3>
<PRE>
public <B>IndexWriter</B>(<A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store">Directory</A>&nbsp;d,
                   <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.html" title="class in org.apache.lucene.index">IndexWriterConfig</A>&nbsp;conf)
            throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Constructs a new IndexWriter per the settings given in <code>conf</code>.
 If you want to make "live" changes to this writer instance, use
 <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#getConfig()"><CODE>getConfig()</CODE></A>.
 
 <p>
 <b>NOTE:</b> after ths writer is created, the given configuration instance
 cannot be passed to another writer. If you intend to do so, you should
 <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.html#clone()"><CODE>clone</CODE></A> it beforehand.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - the index directory. The index is either created or appended
          according <code>conf.getOpenMode()</code>.<DD><CODE>conf</CODE> - the configuration settings according to which IndexWriter should
          be initialized.
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if the directory cannot be read/written to, or if it does not
           exist and <code>conf.getOpenMode()</code> is
           <code>OpenMode.APPEND</code> or if there is any other low-level
           IO error</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="numDeletedDocs(org.apache.lucene.index.SegmentInfoPerCommit)"><!-- --></A><H3>
numDeletedDocs</H3>
<PRE>
public int <B>numDeletedDocs</B>(<A HREF="../../../../org/apache/lucene/index/SegmentInfoPerCommit.html" title="class in org.apache.lucene.index">SegmentInfoPerCommit</A>&nbsp;info)</PRE>
<DL>
<DD>Obtain the number of deleted docs for a pooled reader.
 If the reader isn't being pooled, the segmentInfo's 
 delCount is returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="ensureOpen(boolean)"><!-- --></A><H3>
ensureOpen</H3>
<PRE>
protected final void <B>ensureOpen</B>(boolean&nbsp;failIfClosing)
                         throws <A HREF="../../../../org/apache/lucene/store/AlreadyClosedException.html" title="class in org.apache.lucene.store">AlreadyClosedException</A></PRE>
<DL>
<DD>Used internally to throw an <A HREF="../../../../org/apache/lucene/store/AlreadyClosedException.html" title="class in org.apache.lucene.store"><CODE>AlreadyClosedException</CODE></A> if this
 IndexWriter has been closed or is in the process of closing.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>failIfClosing</CODE> - if true, also fail when <code>IndexWriter</code> is in the process of
          closing (<code>closing=true</code>) but not yet done closing (
          <code>closed=false</code>)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/store/AlreadyClosedException.html" title="class in org.apache.lucene.store">AlreadyClosedException</A></CODE> - if this IndexWriter is closed or in the process of closing</DL>
</DD>
</DL>
<HR>

<A NAME="ensureOpen()"><!-- --></A><H3>
ensureOpen</H3>
<PRE>
protected final void <B>ensureOpen</B>()
                         throws <A HREF="../../../../org/apache/lucene/store/AlreadyClosedException.html" title="class in org.apache.lucene.store">AlreadyClosedException</A></PRE>
<DL>
<DD>Used internally to throw an <A HREF="../../../../org/apache/lucene/store/AlreadyClosedException.html" title="class in org.apache.lucene.store"><CODE>AlreadyClosedException</CODE></A> if this IndexWriter has been
 closed (<code>closed=true</code>) or is in the process of
 closing (<code>closing=true</code>).
 <p>
 Calls <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#ensureOpen(boolean)"><CODE>ensureOpen(true)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/store/AlreadyClosedException.html" title="class in org.apache.lucene.store">AlreadyClosedException</A></CODE> - if this IndexWriter is closed</DL>
</DD>
</DL>
<HR>

<A NAME="getConfig()"><!-- --></A><H3>
getConfig</H3>
<PRE>
public <A HREF="../../../../org/apache/lucene/index/LiveIndexWriterConfig.html" title="class in org.apache.lucene.index">LiveIndexWriterConfig</A> <B>getConfig</B>()</PRE>
<DL>
<DD>Returns a <A HREF="../../../../org/apache/lucene/index/LiveIndexWriterConfig.html" title="class in org.apache.lucene.index"><CODE>LiveIndexWriterConfig</CODE></A>, which can be used to query the IndexWriter
 current settings, as well as modify "live" ones.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Commits all changes to an index, waits for pending merges
 to complete, and closes all associated files.  
 <p>
 This is a "slow graceful shutdown" which may take a long time
 especially if a big merge is pending: If you only want to close
 resources use <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#rollback()"><CODE>rollback()</CODE></A>. If you only want to commit
 pending changes and close resources see <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#close(boolean)"><CODE>close(boolean)</CODE></A>.
 <p>
 Note that this may be a costly
 operation, so, try to re-use a single writer instead of
 closing and opening a new one.  See <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#commit()"><CODE>commit()</CODE></A> for
 caveats about write caching done by some IO devices.

 <p> If an Exception is hit during close, eg due to disk
 full or some other reason, then both the on-disk index
 and the internal state of the IndexWriter instance will
 be consistent.  However, the close will not be complete
 even though part of it (flushing buffered documents)
 may have succeeded, so the write lock will still be
 held.</p>

 <p> If you can correct the underlying cause (eg free up
 some disk space) then you can call close() again.
 Failing that, if you want to force the write lock to be
 released (dangerous, because you may then lose buffered
 docs in the IndexWriter instance) then you can do
 something like this:</p>

 <pre class="prettyprint">
 try {
   writer.close();
 } finally {
   if (IndexWriter.isLocked(directory)) {
     IndexWriter.unlock(directory);
   }
 }
 </pre>

 after which, you must be certain not to use the writer
 instance anymore.</p>

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer, again.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/Closeable.html?is-external=true#close()" title="class or interface in java.io">close</A></CODE> in interface <CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/Closeable.html?is-external=true" title="class or interface in java.io">Closeable</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="close(boolean)"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>(boolean&nbsp;waitForMerges)
           throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Closes the index with or without waiting for currently
 running merges to finish.  This is only meaningful when
 using a MergeScheduler that runs merges in background
 threads.

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer, again.  See <a
 href="#OOME">above</a> for details.</p>

 <p><b>NOTE</b>: it is dangerous to always call
 close(false), especially when IndexWriter is not open
 for very long, because this can result in "merge
 starvation" whereby long merges will never have a
 chance to finish.  This will cause too many segments in
 your index over time.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>waitForMerges</CODE> - if true, this call will block
 until all merges complete; else, it will ask all
 running merges to abort, wait until those merges have
 finished (which should be at most a few seconds), and
 then return.
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getDirectory()"><!-- --></A><H3>
getDirectory</H3>
<PRE>
public <A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store">Directory</A> <B>getDirectory</B>()</PRE>
<DL>
<DD>Returns the Directory used by this index.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAnalyzer()"><!-- --></A><H3>
getAnalyzer</H3>
<PRE>
public <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A> <B>getAnalyzer</B>()</PRE>
<DL>
<DD>Returns the analyzer used by this index.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="maxDoc()"><!-- --></A><H3>
maxDoc</H3>
<PRE>
public int <B>maxDoc</B>()</PRE>
<DL>
<DD>Returns total number of docs in this index, including
  docs not yet flushed (still in the RAM buffer),
  not counting deletions.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#numDocs()"><CODE>numDocs()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="numDocs()"><!-- --></A><H3>
numDocs</H3>
<PRE>
public int <B>numDocs</B>()</PRE>
<DL>
<DD>Returns total number of docs in this index, including
  docs not yet flushed (still in the RAM buffer), and
  including deletions.  <b>NOTE:</b> buffered deletions
  are not counted.  If you really need these to be
  counted you should call <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#commit()"><CODE>commit()</CODE></A> first.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#numDocs()"><CODE>numDocs()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasDeletions()"><!-- --></A><H3>
hasDeletions</H3>
<PRE>
public boolean <B>hasDeletions</B>()</PRE>
<DL>
<DD>Returns true if this index has deletions (including buffered deletions).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addDocument(java.lang.Iterable)"><!-- --></A><H3>
addDocument</H3>
<PRE>
public void <B>addDocument</B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&nbsp;doc)
                 throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Adds a document to this index.

 <p> Note that if an Exception is hit (for example disk full)
 then the index will be consistent, but this document
 may not have been added.  Furthermore, it's possible
 the index will have one segment in non-compound format
 even when using compound files (when a merge has
 partially succeeded).</p>

 <p> This method periodically flushes pending documents
 to the Directory (see <a href="#flush">above</a>), and
 also periodically triggers segment merges in the index
 according to the <A HREF="../../../../org/apache/lucene/index/MergePolicy.html" title="class in org.apache.lucene.index"><CODE>MergePolicy</CODE></A> in use.</p>

 <p>Merges temporarily consume space in the
 directory. The amount of space required is up to 1X the
 size of all segments being merged, when no
 readers/searchers are open against the index, and up to
 2X the size of all segments being merged when
 readers/searchers are open against the index (see
 <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMerge(int)"><CODE>forceMerge(int)</CODE></A> for details). The sequence of
 primitive merge operations performed is governed by the
 merge policy.

 <p>Note that each term in the document can be no longer
 than 16383 characters, otherwise an
 IllegalArgumentException will be thrown.</p>

 <p>Note that it's possible to create an invalid Unicode
 string in java if a UTF16 surrogate pair is malformed.
 In this case, the invalid characters are silently
 replaced with the Unicode replacement character
 U+FFFD.</p>

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="addDocument(java.lang.Iterable, org.apache.lucene.analysis.Analyzer)"><!-- --></A><H3>
addDocument</H3>
<PRE>
public void <B>addDocument</B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&nbsp;doc,
                        <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A>&nbsp;analyzer)
                 throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Adds a document to this index, using the provided analyzer instead of the
 value of <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#getAnalyzer()"><CODE>getAnalyzer()</CODE></A>.

 <p>See <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addDocument(java.lang.Iterable)"><CODE>addDocument(Iterable)</CODE></A> for details on
 index and IndexWriter state after an Exception, and
 flushing/merging temporary free space requirements.</p>

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="addDocuments(java.lang.Iterable)"><!-- --></A><H3>
addDocuments</H3>
<PRE>
public void <B>addDocuments</B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&gt;&nbsp;docs)
                  throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Atomically adds a block of documents with sequentially
 assigned document IDs, such that an external reader
 will see all or none of the documents.

 <p><b>WARNING</b>: the index does not currently record
 which documents were added as a block.  Today this is
 fine, because merging will preserve a block. The order of
 documents within a segment will be preserved, even when child
 documents within a block are deleted. Most search features
 (like result grouping and block joining) require you to
 mark documents; when these documents are deleted these
 search features will not work as expected. Obviously adding
 documents to an existing block will require you the reindex
 the entire block.

 <p>However it's possible that in the future Lucene may
 merge more aggressively re-order documents (for example,
 perhaps to obtain better index compression), in which case
 you may need to fully re-index your documents at that time.

 <p>See <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addDocument(java.lang.Iterable)"><CODE>addDocument(Iterable)</CODE></A> for details on
 index and IndexWriter state after an Exception, and
 flushing/merging temporary free space requirements.</p>

 <p><b>NOTE</b>: tools that do offline splitting of an index
 (for example, IndexSplitter in contrib) or
 re-sorting of documents (for example, IndexSorter in
 contrib) are not aware of these atomically added documents
 and will likely break them up.  Use such tools at your
 own risk!

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error<DT><B>WARNING: This API is experimental and might change in incompatible ways in the next release.</B></DT>
  <DD></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="addDocuments(java.lang.Iterable, org.apache.lucene.analysis.Analyzer)"><!-- --></A><H3>
addDocuments</H3>
<PRE>
public void <B>addDocuments</B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&gt;&nbsp;docs,
                         <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A>&nbsp;analyzer)
                  throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Atomically adds a block of documents, analyzed using the
 provided analyzer, with sequentially assigned document
 IDs, such that an external reader will see all or none
 of the documents.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error<DT><B>WARNING: This API is experimental and might change in incompatible ways in the next release.</B></DT>
  <DD></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="updateDocuments(org.apache.lucene.index.Term, java.lang.Iterable)"><!-- --></A><H3>
updateDocuments</H3>
<PRE>
public void <B>updateDocuments</B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>&nbsp;delTerm,
                            <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&gt;&nbsp;docs)
                     throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Atomically deletes documents matching the provided
 delTerm and adds a block of documents with sequentially
 assigned document IDs, such that an external reader
 will see all or none of the documents. 

 See <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addDocuments(java.lang.Iterable)"><CODE>addDocuments(Iterable)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error<DT><B>WARNING: This API is experimental and might change in incompatible ways in the next release.</B></DT>
  <DD></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="updateDocuments(org.apache.lucene.index.Term, java.lang.Iterable, org.apache.lucene.analysis.Analyzer)"><!-- --></A><H3>
updateDocuments</H3>
<PRE>
public void <B>updateDocuments</B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>&nbsp;delTerm,
                            <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&gt;&nbsp;docs,
                            <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A>&nbsp;analyzer)
                     throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Atomically deletes documents matching the provided
 delTerm and adds a block of documents, analyzed  using
 the provided analyzer, with sequentially
 assigned document IDs, such that an external reader
 will see all or none of the documents. 

 See <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addDocuments(java.lang.Iterable)"><CODE>addDocuments(Iterable)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error<DT><B>WARNING: This API is experimental and might change in incompatible ways in the next release.</B></DT>
  <DD></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="deleteDocuments(org.apache.lucene.index.Term)"><!-- --></A><H3>
deleteDocuments</H3>
<PRE>
public void <B>deleteDocuments</B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>&nbsp;term)
                     throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Deletes the document(s) containing <code>term</code>.

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>term</CODE> - the term to identify the documents to be deleted
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="tryDeleteDocument(org.apache.lucene.index.IndexReader, int)"><!-- --></A><H3>
tryDeleteDocument</H3>
<PRE>
public boolean <B>tryDeleteDocument</B>(<A HREF="../../../../org/apache/lucene/index/IndexReader.html" title="class in org.apache.lucene.index">IndexReader</A>&nbsp;readerIn,
                                 int&nbsp;docID)
                          throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Expert: attempts to delete by document ID, as long as
  the provided reader is a near-real-time reader (from <A HREF="../../../../org/apache/lucene/index/DirectoryReader.html#open(org.apache.lucene.index.IndexWriter, boolean)"><CODE>DirectoryReader.open(IndexWriter,boolean)</CODE></A>).  If the
  provided reader is an NRT reader obtained from this
  writer, and its segment has not been merged away, then
  the delete succeeds and this method returns true; else, it
  returns false the caller must then separately delete by
  Term or Query.

  <b>NOTE</b>: this method can only delete documents
  visible to the currently open NRT reader.  If you need
  to delete documents indexed after opening the NRT
  reader you must use the other deleteDocument methods
  (e.g., <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteDocuments(org.apache.lucene.index.Term)"><CODE>deleteDocuments(Term)</CODE></A>).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="deleteDocuments(org.apache.lucene.index.Term...)"><!-- --></A><H3>
deleteDocuments</H3>
<PRE>
public void <B>deleteDocuments</B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>...&nbsp;terms)
                     throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Deletes the document(s) containing any of the
 terms. All given deletes are applied and flushed atomically
 at the same time.

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>terms</CODE> - array of terms to identify the documents
 to be deleted
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="deleteDocuments(org.apache.lucene.search.Query)"><!-- --></A><H3>
deleteDocuments</H3>
<PRE>
public void <B>deleteDocuments</B>(<A HREF="../../../../org/apache/lucene/search/Query.html" title="class in org.apache.lucene.search">Query</A>&nbsp;query)
                     throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Deletes the document(s) matching the provided query.

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>query</CODE> - the query to identify the documents to be deleted
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="deleteDocuments(org.apache.lucene.search.Query...)"><!-- --></A><H3>
deleteDocuments</H3>
<PRE>
public void <B>deleteDocuments</B>(<A HREF="../../../../org/apache/lucene/search/Query.html" title="class in org.apache.lucene.search">Query</A>...&nbsp;queries)
                     throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Deletes the document(s) matching any of the provided queries.
 All given deletes are applied and flushed atomically at the same time.

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>queries</CODE> - array of queries to identify the documents
 to be deleted
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="updateDocument(org.apache.lucene.index.Term, java.lang.Iterable)"><!-- --></A><H3>
updateDocument</H3>
<PRE>
public void <B>updateDocument</B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>&nbsp;term,
                           <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&nbsp;doc)
                    throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Updates a document by first deleting the document(s)
 containing <code>term</code> and then adding the new
 document.  The delete and then add are atomic as seen
 by a reader on the same index (flush may happen only after
 the add).

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>term</CODE> - the term to identify the document(s) to be
 deleted<DD><CODE>doc</CODE> - the document to be added
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="updateDocument(org.apache.lucene.index.Term, java.lang.Iterable, org.apache.lucene.analysis.Analyzer)"><!-- --></A><H3>
updateDocument</H3>
<PRE>
public void <B>updateDocument</B>(<A HREF="../../../../org/apache/lucene/index/Term.html" title="class in org.apache.lucene.index">Term</A>&nbsp;term,
                           <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;? extends <A HREF="../../../../org/apache/lucene/index/IndexableField.html" title="interface in org.apache.lucene.index">IndexableField</A>&gt;&nbsp;doc,
                           <A HREF="../../../../org/apache/lucene/analysis/Analyzer.html" title="class in org.apache.lucene.analysis">Analyzer</A>&nbsp;analyzer)
                    throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Updates a document by first deleting the document(s)
 containing <code>term</code> and then adding the new
 document.  The delete and then add are atomic as seen
 by a reader on the same index (flush may happen only after
 the add).

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>term</CODE> - the term to identify the document(s) to be
 deleted<DD><CODE>doc</CODE> - the document to be added<DD><CODE>analyzer</CODE> - the analyzer to use when analyzing the document
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="forceMerge(int)"><!-- --></A><H3>
forceMerge</H3>
<PRE>
public void <B>forceMerge</B>(int&nbsp;maxNumSegments)
                throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Forces merge policy to merge segments until there are <=
 maxNumSegments.  The actual merges to be
 executed are determined by the <A HREF="../../../../org/apache/lucene/index/MergePolicy.html" title="class in org.apache.lucene.index"><CODE>MergePolicy</CODE></A>.

 <p>This is a horribly costly operation, especially when
 you pass a small <code>maxNumSegments</code>; usually you
 should only call this if the index is static (will no
 longer be changed).</p>

 <p>Note that this requires up to 2X the index size free
 space in your Directory (3X if you're using compound
 file format).  For example, if your index size is 10 MB
 then you need up to 20 MB free for this to complete (30
 MB if you're using compound file format).  Also,
 it's best to call <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#commit()"><CODE>commit()</CODE></A> afterwards,
 to allow IndexWriter to free up disk space.</p>

 <p>If some but not all readers re-open while merging
 is underway, this will cause > 2X temporary
 space to be consumed as those new readers will then
 hold open the temporary segments at that time.  It is
 best not to re-open readers while merging is running.</p>

 <p>The actual temporary usage could be much less than
 these figures (it depends on many factors).</p>

 <p>In general, once this completes, the total size of the
 index will be less than the size of the starting index.
 It could be quite a bit smaller (if there were many
 pending deletes) or just slightly smaller.</p>

 <p>If an Exception is hit, for example
 due to disk full, the index will not be corrupted and no
 documents will be lost.  However, it may have
 been partially merged (some segments were merged but
 not all), and it's possible that one of the segments in
 the index will be in non-compound format even when
 using compound file format.  This will occur when the
 Exception is hit during conversion of the segment into
 compound format.</p>

 <p>This call will merge those segments present in
 the index when the call started.  If other threads are
 still adding documents and flushing segments, those
 newly created segments will not be merged unless you
 call forceMerge again.</p>

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>

 <p><b>NOTE</b>: if you call <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#close(boolean)"><CODE>close(boolean)</CODE></A>
 with <tt>false</tt>, which aborts all running merges,
 then any thread still running this method might hit a
 <A HREF="../../../../org/apache/lucene/index/MergePolicy.MergeAbortedException.html" title="class in org.apache.lucene.index"><CODE>MergePolicy.MergeAbortedException</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>maxNumSegments</CODE> - maximum number of segments left
 in the index after merging finishes
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error<DT><B>See Also:</B><DD><A HREF="../../../../org/apache/lucene/index/MergePolicy.html#findMerges(org.apache.lucene.index.MergePolicy.MergeTrigger, org.apache.lucene.index.SegmentInfos)"><CODE>MergePolicy.findMerges(org.apache.lucene.index.MergePolicy.MergeTrigger, org.apache.lucene.index.SegmentInfos)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="forceMerge(int, boolean)"><!-- --></A><H3>
forceMerge</H3>
<PRE>
public void <B>forceMerge</B>(int&nbsp;maxNumSegments,
                       boolean&nbsp;doWait)
                throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Just like <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMerge(int)"><CODE>forceMerge(int)</CODE></A>, except you can
  specify whether the call should block until
  all merging completes.  This is only meaningful with a
  <A HREF="../../../../org/apache/lucene/index/MergeScheduler.html" title="class in org.apache.lucene.index"><CODE>MergeScheduler</CODE></A> that is able to run merges in
  background threads.

  <p><b>NOTE</b>: if this method hits an OutOfMemoryError
  you should immediately close the writer.  See <a
  href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="forceMergeDeletes(boolean)"><!-- --></A><H3>
forceMergeDeletes</H3>
<PRE>
public void <B>forceMergeDeletes</B>(boolean&nbsp;doWait)
                       throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Just like <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMergeDeletes()"><CODE>forceMergeDeletes()</CODE></A>, except you can
  specify whether the call should block until the
  operation completes.  This is only meaningful with a
  <A HREF="../../../../org/apache/lucene/index/MergeScheduler.html" title="class in org.apache.lucene.index"><CODE>MergeScheduler</CODE></A> that is able to run merges in
  background threads.

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>

 <p><b>NOTE</b>: if you call <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#close(boolean)"><CODE>close(boolean)</CODE></A>
 with <tt>false</tt>, which aborts all running merges,
 then any thread still running this method might hit a
 <A HREF="../../../../org/apache/lucene/index/MergePolicy.MergeAbortedException.html" title="class in org.apache.lucene.index"><CODE>MergePolicy.MergeAbortedException</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="forceMergeDeletes()"><!-- --></A><H3>
forceMergeDeletes</H3>
<PRE>
public void <B>forceMergeDeletes</B>()
                       throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Forces merging of all segments that have deleted
  documents.  The actual merges to be executed are
  determined by the <A HREF="../../../../org/apache/lucene/index/MergePolicy.html" title="class in org.apache.lucene.index"><CODE>MergePolicy</CODE></A>.  For example,
  the default <A HREF="../../../../org/apache/lucene/index/TieredMergePolicy.html" title="class in org.apache.lucene.index"><CODE>TieredMergePolicy</CODE></A> will only
  pick a segment if the percentage of
  deleted docs is over 10%.

  <p>This is often a horribly costly operation; rarely
  is it warranted.</p>

  <p>To see how
  many deletions you have pending in your index, call
  <A HREF="../../../../org/apache/lucene/index/IndexReader.html#numDeletedDocs()"><CODE>IndexReader.numDeletedDocs()</CODE></A>.</p>

  <p><b>NOTE</b>: this method first flushes a new
  segment (if there are indexed documents), and applies
  all buffered deletes.

  <p><b>NOTE</b>: if this method hits an OutOfMemoryError
  you should immediately close the writer.  See <a
  href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="maybeMerge()"><!-- --></A><H3>
maybeMerge</H3>
<PRE>
public final void <B>maybeMerge</B>()
                      throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Expert: asks the mergePolicy whether any merges are
 necessary now and if so, runs the requested merges and
 then iterate (test again if merges are needed) until no
 more merges are returned by the mergePolicy.

 Explicit calls to maybeMerge() are usually not
 necessary. The most common case is when merge policy
 parameters have changed.
 
 This method will call the <A HREF="../../../../org/apache/lucene/index/MergePolicy.html" title="class in org.apache.lucene.index"><CODE>MergePolicy</CODE></A> with
 <A HREF="../../../../org/apache/lucene/index/MergePolicy.MergeTrigger.html#EXPLICIT"><CODE>MergePolicy.MergeTrigger.EXPLICIT</CODE></A>.

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getMergingSegments()"><!-- --></A><H3>
getMergingSegments</H3>
<PRE>
public <A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</A>&lt;<A HREF="../../../../org/apache/lucene/index/SegmentInfoPerCommit.html" title="class in org.apache.lucene.index">SegmentInfoPerCommit</A>&gt; <B>getMergingSegments</B>()</PRE>
<DL>
<DD>Expert: to be used by a <A HREF="../../../../org/apache/lucene/index/MergePolicy.html" title="class in org.apache.lucene.index"><CODE>MergePolicy</CODE></A> to avoid
  selecting merges for segments already being merged.
  The returned collection is not cloned, and thus is
  only safe to access if you hold IndexWriter's lock
  (which you do when IndexWriter invokes the
  MergePolicy).

  <p>Do not alter the returned collection!
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNextMerge()"><!-- --></A><H3>
getNextMerge</H3>
<PRE>
public <A HREF="../../../../org/apache/lucene/index/MergePolicy.OneMerge.html" title="class in org.apache.lucene.index">MergePolicy.OneMerge</A> <B>getNextMerge</B>()</PRE>
<DL>
<DD>Expert: the <A HREF="../../../../org/apache/lucene/index/MergeScheduler.html" title="class in org.apache.lucene.index"><CODE>MergeScheduler</CODE></A> calls this method to retrieve the next
 merge requested by the MergePolicy
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>WARNING: This API is experimental and might change in incompatible ways in the next release.</B></DT>
  <DD></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hasPendingMerges()"><!-- --></A><H3>
hasPendingMerges</H3>
<PRE>
public boolean <B>hasPendingMerges</B>()</PRE>
<DL>
<DD>Expert: returns true if there are merges waiting to be scheduled.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>WARNING: This API is experimental and might change in incompatible ways in the next release.</B></DT>
  <DD></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="rollback()"><!-- --></A><H3>
rollback</H3>
<PRE>
public void <B>rollback</B>()
              throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Close the <code>IndexWriter</code> without committing
 any changes that have occurred since the last commit
 (or since it was opened, if commit hasn't been called).
 This removes any temporary files that had been created,
 after which the state of the index will be the same as
 it was when commit() was last called or when this
 writer was first opened.  This also clears a previous
 call to <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#prepareCommit()"><CODE>prepareCommit()</CODE></A>.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../org/apache/lucene/index/TwoPhaseCommit.html#rollback()">rollback</A></CODE> in interface <CODE><A HREF="../../../../org/apache/lucene/index/TwoPhaseCommit.html" title="interface in org.apache.lucene.index">TwoPhaseCommit</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="deleteAll()"><!-- --></A><H3>
deleteAll</H3>
<PRE>
public void <B>deleteAll</B>()
               throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Delete all documents in the index.

 <p>This method will drop all buffered documents and will
    remove all segments from the index. This change will not be
    visible until a <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#commit()"><CODE>commit()</CODE></A> has been called. This method
    can be rolled back using <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#rollback()"><CODE>rollback()</CODE></A>.</p>

 <p>NOTE: this method is much faster than using deleteDocuments( new MatchAllDocsQuery() ). 
    Yet, this method also has different semantics compared to <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteDocuments(org.apache.lucene.search.Query)"><CODE>deleteDocuments(Query)</CODE></A> 
    / <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteDocuments(org.apache.lucene.search.Query...)"><CODE>deleteDocuments(Query...)</CODE></A> since internal data-structures are cleared as well 
    as all segment information is forcefully dropped anti-viral semantics like omitting norms
    are reset or doc value types are cleared. Essentially a call to <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#deleteAll()"><CODE>deleteAll()</CODE></A> is equivalent
    to creating a new <A HREF="../../../../org/apache/lucene/index/IndexWriter.html" title="class in org.apache.lucene.index"><CODE>IndexWriter</CODE></A> with <A HREF="../../../../org/apache/lucene/index/IndexWriterConfig.OpenMode.html#CREATE"><CODE>IndexWriterConfig.OpenMode.CREATE</CODE></A> which a delete query only marks
    documents as deleted.</p>

 <p>NOTE: this method will forcefully abort all merges
    in progress.  If other threads are running <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMerge(int)"><CODE>forceMerge(int)</CODE></A>, <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addIndexes(org.apache.lucene.index.IndexReader...)"><CODE>addIndexes(IndexReader[])</CODE></A> or
    <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMergeDeletes(boolean)"><CODE>forceMergeDeletes(boolean)</CODE></A> methods, they may receive
    <A HREF="../../../../org/apache/lucene/index/MergePolicy.MergeAbortedException.html" title="class in org.apache.lucene.index"><CODE>MergePolicy.MergeAbortedException</CODE></A>s.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="waitForMerges()"><!-- --></A><H3>
waitForMerges</H3>
<PRE>
public void <B>waitForMerges</B>()</PRE>
<DL>
<DD>Wait for any currently outstanding merges to finish.

 <p>It is guaranteed that any merges started prior to calling this method
    will have completed once this method completes.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addIndexes(org.apache.lucene.store.Directory...)"><!-- --></A><H3>
addIndexes</H3>
<PRE>
public void <B>addIndexes</B>(<A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store">Directory</A>...&nbsp;dirs)
                throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Adds all segments from an array of indexes into this index.

 <p>This may be used to parallelize batch indexing. A large document
 collection can be broken into sub-collections. Each sub-collection can be
 indexed in parallel, on a different thread, process or machine. The
 complete index can then be created by merging sub-collection indexes
 with this method.

 <p>
 <b>NOTE:</b> the index in each <A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store"><CODE>Directory</CODE></A> must not be
 changed (opened by a writer) while this method is
 running.  This method does not acquire a write lock in
 each input Directory, so it is up to the caller to
 enforce this.

 <p>This method is transactional in how Exceptions are
 handled: it does not commit a new segments_N file until
 all indexes are added.  This means if an Exception
 occurs (for example disk full), then either no indexes
 will have been added or they all will have been.

 <p>Note that this requires temporary free space in the
 <A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store"><CODE>Directory</CODE></A> up to 2X the sum of all input indexes
 (including the starting index). If readers/searchers
 are open against the starting index, then temporary
 free space required will be higher by the size of the
 starting index (see <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#forceMerge(int)"><CODE>forceMerge(int)</CODE></A> for details).

 <p>
 <b>NOTE:</b> this method only copies the segments of the incoming indexes
 and does not merge them. Therefore deleted documents are not removed and
 the new segments are not merged with the existing ones.

 <p>This requires this index not be among those to be added.

 <p>
 <b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer. See <a
 href="#OOME">above</a> for details.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="addIndexes(org.apache.lucene.index.IndexReader...)"><!-- --></A><H3>
addIndexes</H3>
<PRE>
public void <B>addIndexes</B>(<A HREF="../../../../org/apache/lucene/index/IndexReader.html" title="class in org.apache.lucene.index">IndexReader</A>...&nbsp;readers)
                throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Merges the provided indexes into this index.
 
 <p>
 The provided IndexReaders are not closed.
 
 <p>
 See <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#addIndexes(org.apache.lucene.store.Directory...)"><CODE>addIndexes(org.apache.lucene.store.Directory...)</CODE></A> for details on transactional semantics, temporary
 free space required in the Directory, and non-CFS segments on an Exception.
 
 <p>
 <b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately
 close the writer. See <a href="#OOME">above</a> for details.
 
 <p>
 <b>NOTE:</b> empty segments are dropped by this method and not added to this
 index.
 
 <p>
 <b>NOTE:</b> this method merges all given <A HREF="../../../../org/apache/lucene/index/IndexReader.html" title="class in org.apache.lucene.index"><CODE>IndexReader</CODE></A>s in one
 merge. If you intend to merge a large number of readers, it may be better
 to call this method multiple times, each time with a small set of readers.
 In principle, if you use a merge policy with a <code>mergeFactor</code> or
 <code>maxMergeAtOnce</code> parameter, you should pass that many readers in one
 call. Also, if the given readers are <A HREF="../../../../org/apache/lucene/index/DirectoryReader.html" title="class in org.apache.lucene.index"><CODE>DirectoryReader</CODE></A>s, they can be
 opened with <code>termIndexInterval=-1</code> to save RAM, since during merge
 the in-memory structure is not used. See
 <A HREF="../../../../org/apache/lucene/index/DirectoryReader.html#open(org.apache.lucene.store.Directory, int)"><CODE>DirectoryReader.open(Directory, int)</CODE></A>.
 
 <p>
 <b>NOTE</b>: if you call <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#close(boolean)"><CODE>close(boolean)</CODE></A> with <tt>false</tt>, which
 aborts all running merges, then any thread still running this method might
 hit a <A HREF="../../../../org/apache/lucene/index/MergePolicy.MergeAbortedException.html" title="class in org.apache.lucene.index"><CODE>MergePolicy.MergeAbortedException</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/apache/lucene/index/CorruptIndexException.html" title="class in org.apache.lucene.index">CorruptIndexException</A></CODE> - if the index is corrupt
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="doAfterFlush()"><!-- --></A><H3>
doAfterFlush</H3>
<PRE>
protected void <B>doAfterFlush</B>()
                     throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>A hook for extending classes to execute operations after pending added and
 deleted documents have been flushed to the Directory but before the change
 is committed (new segments_N file written).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="doBeforeFlush()"><!-- --></A><H3>
doBeforeFlush</H3>
<PRE>
protected void <B>doBeforeFlush</B>()
                      throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>A hook for extending classes to execute operations before pending added and
 deleted documents are flushed to the Directory.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="prepareCommit()"><!-- --></A><H3>
prepareCommit</H3>
<PRE>
public final void <B>prepareCommit</B>()
                         throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD><p>Expert: prepare for commit.  This does the
  first phase of 2-phase commit. This method does all
  steps necessary to commit changes since this writer
  was opened: flushes pending added and deleted docs,
  syncs the index files, writes most of next segments_N
  file.  After calling this you must call either <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#commit()"><CODE>commit()</CODE></A> to finish the commit, or <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#rollback()"><CODE>rollback()</CODE></A> to revert the commit and undo all changes
  done since the writer was opened.</p>

 <p>You can also just call <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#commit()"><CODE>commit()</CODE></A> directly
  without prepareCommit first in which case that method
  will internally call prepareCommit.

  <p><b>NOTE</b>: if this method hits an OutOfMemoryError
  you should immediately close the writer.  See <a
  href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../org/apache/lucene/index/TwoPhaseCommit.html#prepareCommit()">prepareCommit</A></CODE> in interface <CODE><A HREF="../../../../org/apache/lucene/index/TwoPhaseCommit.html" title="interface in org.apache.lucene.index">TwoPhaseCommit</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setCommitData(java.util.Map)"><!-- --></A><H3>
setCommitData</H3>
<PRE>
public final void <B>setCommitData</B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>,<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&gt;&nbsp;commitUserData)</PRE>
<DL>
<DD>Sets the commit user data map. That method is considered a transaction by
 <A HREF="../../../../org/apache/lucene/index/IndexWriter.html" title="class in org.apache.lucene.index"><CODE>IndexWriter</CODE></A> and will be <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#commit()"><CODE>committed</CODE></A> even if no other
 changes were made to the writer instance. Note that you must call this method
 before <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#prepareCommit()"><CODE>prepareCommit()</CODE></A>, or otherwise it won't be included in the
 follow-on <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#commit()"><CODE>commit()</CODE></A>.
 <p>
 <b>NOTE:</b> the map is cloned internally, therefore altering the map's
 contents after calling this method has no effect.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCommitData()"><!-- --></A><H3>
getCommitData</H3>
<PRE>
public final <A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</A>&lt;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>,<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A>&gt; <B>getCommitData</B>()</PRE>
<DL>
<DD>Returns the commit user data map that was last committed, or the one that
 was set on <A HREF="../../../../org/apache/lucene/index/IndexWriter.html#setCommitData(java.util.Map)"><CODE>setCommitData(Map)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="commit()"><!-- --></A><H3>
commit</H3>
<PRE>
public final void <B>commit</B>()
                  throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD><p>Commits all pending changes (added & deleted
 documents, segment merges, added
 indexes, etc.) to the index, and syncs all referenced
 index files, such that a reader will see the changes
 and the index updates will survive an OS or machine
 crash or power loss.  Note that this does not wait for
 any running background merges to finish.  This may be a
 costly operation, so you should test the cost in your
 application and do it only when really necessary.</p>

 <p> Note that this operation calls Directory.sync on
 the index files.  That call should not return until the
 file contents & metadata are on stable storage.  For
 FSDirectory, this calls the OS's fsync.  But, beware:
 some hardware devices may in fact cache writes even
 during fsync, and return before the bits are actually
 on stable storage, to give the appearance of faster
 performance.  If you have such a device, and it does
 not have a battery backup (for example) then on power
 loss it may still lose data.  Lucene cannot guarantee
 consistency on such devices.  </p>

 <p><b>NOTE</b>: if this method hits an OutOfMemoryError
 you should immediately close the writer.  See <a
 href="#OOME">above</a> for details.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../org/apache/lucene/index/TwoPhaseCommit.html#commit()">commit</A></CODE> in interface <CODE><A HREF="../../../../org/apache/lucene/index/TwoPhaseCommit.html" title="interface in org.apache.lucene.index">TwoPhaseCommit</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE><DT><B>See Also:</B><DD><A HREF="../../../../org/apache/lucene/index/IndexWriter.html#prepareCommit()"><CODE>prepareCommit()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasUncommittedChanges()"><!-- --></A><H3>
hasUncommittedChanges</H3>
<PRE>
public final boolean <B>hasUncommittedChanges</B>()</PRE>
<DL>
<DD>Returns true if there are changes that have not been committed
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="flush(boolean, boolean)"><!-- --></A><H3>
flush</H3>
<PRE>
protected final void <B>flush</B>(boolean&nbsp;triggerMerge,
                           boolean&nbsp;applyAllDeletes)
                    throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Flush all in-memory buffered updates (adds and deletes)
 to the Directory.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>triggerMerge</CODE> - if true, we may merge segments (if
  deletes or docs were flushed) if necessary<DD><CODE>applyAllDeletes</CODE> - whether pending deletes should also
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="ramSizeInBytes()"><!-- --></A><H3>
ramSizeInBytes</H3>
<PRE>
public final long <B>ramSizeInBytes</B>()</PRE>
<DL>
<DD>Expert:  Return the total size of all index files currently cached in memory.
 Useful for size management with flushRamDocs()
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="numRamDocs()"><!-- --></A><H3>
numRamDocs</H3>
<PRE>
public final int <B>numRamDocs</B>()</PRE>
<DL>
<DD>Expert:  Return the number of documents currently
  buffered in RAM.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="merge(org.apache.lucene.index.MergePolicy.OneMerge)"><!-- --></A><H3>
merge</H3>
<PRE>
public void <B>merge</B>(<A HREF="../../../../org/apache/lucene/index/MergePolicy.OneMerge.html" title="class in org.apache.lucene.index">MergePolicy.OneMerge</A>&nbsp;merge)
           throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Merges the indicated segments, replacing them in the stack with a
 single segment.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE><DT><B>WARNING: This API is experimental and might change in incompatible ways in the next release.</B></DT>
  <DD></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="segString()"><!-- --></A><H3>
segString</H3>
<PRE>
public <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>segString</B>()</PRE>
<DL>
<DD>Returns a string description of all segments, for
  debugging.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>NOTE: This API is for internal purposes only and might change in incompatible ways in the next release.</B></DT>
  <DD></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="segString(java.lang.Iterable)"><!-- --></A><H3>
segString</H3>
<PRE>
public <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>segString</B>(<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang">Iterable</A>&lt;<A HREF="../../../../org/apache/lucene/index/SegmentInfoPerCommit.html" title="class in org.apache.lucene.index">SegmentInfoPerCommit</A>&gt;&nbsp;infos)</PRE>
<DL>
<DD>Returns a string description of the specified
  segments, for debugging.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>NOTE: This API is for internal purposes only and might change in incompatible ways in the next release.</B></DT>
  <DD></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="segString(org.apache.lucene.index.SegmentInfoPerCommit)"><!-- --></A><H3>
segString</H3>
<PRE>
public <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>segString</B>(<A HREF="../../../../org/apache/lucene/index/SegmentInfoPerCommit.html" title="class in org.apache.lucene.index">SegmentInfoPerCommit</A>&nbsp;info)</PRE>
<DL>
<DD>Returns a string description of the specified
  segment, for debugging.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>NOTE: This API is for internal purposes only and might change in incompatible ways in the next release.</B></DT>
  <DD></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isLocked(org.apache.lucene.store.Directory)"><!-- --></A><H3>
isLocked</H3>
<PRE>
public static boolean <B>isLocked</B>(<A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store">Directory</A>&nbsp;directory)
                        throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Returns <code>true</code> iff the index in the named directory is
 currently locked.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>directory</CODE> - the directory to check for a lock
<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE> - if there is a low-level IO error</DL>
</DD>
</DL>
<HR>

<A NAME="unlock(org.apache.lucene.store.Directory)"><!-- --></A><H3>
unlock</H3>
<PRE>
public static void <B>unlock</B>(<A HREF="../../../../org/apache/lucene/store/Directory.html" title="class in org.apache.lucene.store">Directory</A>&nbsp;directory)
                   throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Forcibly unlocks the index in the named directory.
 <P>
 Caution: this should only be used by failure recovery code,
 when it is known that no other process nor thread is in fact
 currently accessing this index.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="deleteUnusedFiles()"><!-- --></A><H3>
deleteUnusedFiles</H3>
<PRE>
public void <B>deleteUnusedFiles</B>()
                       throws <A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></PRE>
<DL>
<DD>Expert: remove any index files that are no longer
  used.

  <p> IndexWriter normally deletes unused files itself,
  during indexing.  However, on Windows, which disallows
  deletion of open files, if there is a reader open on
  the index then those files cannot be deleted.  This is
  fine, because IndexWriter will periodically retry
  the deletion.</p>

  <p> However, IndexWriter doesn't try that often: only
  on open, close, flushing a new segment, and finishing
  a merge.  If you don't do any of these actions with your
  IndexWriter, you'll see the unused files linger.  If
  that's a problem, call this method to delete them
  (once you've closed the open readers that were
  preventing their deletion). 
  
  <p> In addition, you can call this method to delete 
  unreferenced index commits. This might be useful if you 
  are using an <A HREF="../../../../org/apache/lucene/index/IndexDeletionPolicy.html" title="class in org.apache.lucene.index"><CODE>IndexDeletionPolicy</CODE></A> which holds
  onto index commits until some criteria are met, but those
  commits are no longer needed. Otherwise, those commits will
  be deleted the next time commit() is called.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</A></CODE></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/IndexWriter.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/lucene/index/IndexUpgrader.html" title="class in org.apache.lucene.index"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/lucene/index/IndexWriter.IndexReaderWarmer.html" title="class in org.apache.lucene.index"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/apache/lucene/index/IndexWriter.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="IndexWriter.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

          <i>Copyright &copy; 2000-2013 Apache Software Foundation.  All Rights Reserved.</i>
          <script src='../../../../prettify.js' type='text/javascript'></script>
          <script type='text/javascript'>
            (function(){
              var oldonload = window.onload;
              if (typeof oldonload != 'function') {
                window.onload = prettyPrint;
              } else {
                window.onload = function() {
                  oldonload();
                  prettyPrint();
                }
              }
            })();
          </script>
        
</BODY>
</HTML>
